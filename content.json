{"meta":{"title":"Aurora","subtitle":"","description":"成长","author":"Pock","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2018-07-13T03:25:33.000Z","updated":"2018-07-13T06:09:12.148Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-07-12T09:43:48.000Z","updated":"2018-07-13T06:08:54.225Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"EGG框架在用forEach或者Map进行遍历调用async方法问题","slug":"EGG框架在用forEach或者Map进行遍历调用async方法问题","date":"2018-07-04T02:20:50.000Z","updated":"2018-07-13T06:04:26.409Z","comments":true,"path":"2018/07/04/EGG框架在用forEach或者Map进行遍历调用async方法问题/","link":"","permalink":"http://yoursite.com/2018/07/04/EGG框架在用forEach或者Map进行遍历调用async方法问题/","excerpt":"EGG框架在用forEach或者Map进行遍历调用async方法问题","text":"EGG框架在用forEach或者Map进行遍历调用async方法问题 0X00 出现的情况12345//假设 newList为一个array类型,这段代码处于async中newList.forEach(x =&gt; x&#123; //这里的的await 会报错,如果不用await这里返回的y就是一个promise对象对于我这种入门的人不太好处理 var y = await this.model.show();&#125;) 0X01 我的解决方法12345//假设 newList为一个array类型,这段代码处于async中for(let i = 0; i &lt; newList.length; i++) &#123; //这里再来调用async方法,这里await方法不会报错,返回的y也是对的 var y = await this.model.show();&#125;","categories":[{"name":"EGG","slug":"EGG","permalink":"http://yoursite.com/categories/EGG/"}],"tags":[{"name":"EGG","slug":"EGG","permalink":"http://yoursite.com/tags/EGG/"}]},{"title":"Git整理","slug":"Git整理","date":"2018-06-13T03:16:19.000Z","updated":"2018-07-13T06:07:28.269Z","comments":true,"path":"2018/06/13/Git整理/","link":"","permalink":"http://yoursite.com/2018/06/13/Git整理/","excerpt":"记录一下容易忘记的GIT命令","text":"记录一下容易忘记的GIT命令 创建SSH Keys 输入指令，进入.ssh文件夹 cd ~/.ssh/如果提示 “ No such file or directory”，你可以手动的创建一个 .ssh文件夹即可 配置全局的name和email，这里是的你github或者bitbucket的name和email git config –global user.name “pockadmin” git config –global user.email “pockadmin@163.com“ 生成key ssh-keygen -t rsa -C “pockadmin@163.com” 连续按三次回车，这里设置的密码就为空了，并且创建了key。 打开Admin目录进入.ssh文件夹，用记事本打开id_rsa.pub，复制里面的内容添加到你github或者bitbucket ssh设置里即可","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"EGG 入门笔记","slug":"EGG 入门笔记","date":"2018-06-04T08:13:37.000Z","updated":"2018-07-13T06:14:26.915Z","comments":true,"path":"2018/06/04/EGG 入门笔记/","link":"","permalink":"http://yoursite.com/2018/06/04/EGG 入门笔记/","excerpt":"EGG框架快速上手","text":"EGG框架快速上手 0X00 这里基于我的情况,需要快速上手 0X01 基于Egg框架的项目启动 找到目录中的package.json,点击右键show npm scripts ,然后dev run,dev run是属于在测试环境中的模式,如果在win环境下跑run的话会出现好多窗口,是因为有多少启动了多个线程,就出现了那么多的窗口 0X02 Egg基本目录结构 controller文件夹和java的一样 extent 属于可选的,可以对框架进行扩展配置,详情见框架扩展 model 是属于Egg的自定义目录规范,详情Loader API public 属于可选,放置静态文件,详情egg-static service 和java的service层一样 router.js 这个主要是路由的配置,相当于servlet配置映射的路径,这个还是比较重要的 0X03 基于RESTful风格的简单的CURD0.Egg中规定的RESTful的请求 ctx的含义 ctx - 当前请求的 Context 实例。 Egg中规定的RESTful的请求 1.简述思路 这里举一个新闻的例子,对新闻进行CURD操作,从model层开始编写,在编写controller层,最后在配置路由router.js配置出RESTful风格的接口(这里不用编写service层是因为我controller继承了一个公共类,其中有最基础的CURD方法,所以说这次上手还是感觉比较简单) 2.Model层的编写,实体的写法 下面是一个新闻的实体 12345678910111213141516'use strict';module.exports = app =&gt; &#123; const mongoose = app.mongoose; const tempSchema = new mongoose.Schema(&#123; _id: mongoose.Schema.Types.ObjectId, tile: String, //标题 content: String, //内容 intro: String, //简介 creation: Number, //创建时间 updated: Number, //更新时间 &#125;, &#123; versionKey: false, &#125;); return mongoose.model('news', tempSchema);&#125;; use strict 表示使用严格模式为什么用严格模式 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 app.mongoose 调用mnogoDB插件 const tempSchema 表示mnogoDB的数据库类型?(暂时不确定,没有使用过mnogoDB) 5到10行就是字段 versionKey: false, 这个一个是个标准的写法吧 return mongoose.model(&#39;news&#39;, tempSchema); 这个可以对应到service层 3.编写Controller层 下面的新闻的controller 123456789101112131415161718192021222324252627282930313233343536373839'use strict';const CommonController = require('./commonController');class NewsController extends CommonController&#123; init() &#123; this.daoService = this.service.news; &#125; async create (ctx) &#123; await super.create(ctx); ctx.logger.debug(\"增加\"); &#125; async show (ctx) &#123; await super.show(ctx); ctx.logger.debug(\"根据ID展示\"); &#125; async index (ctx) &#123; await super.index(ctx); ctx.logger.debug(\"展示所有\"); &#125; async update (ctx) &#123; await super.update(ctx); ctx.logger.debug(\"更新\"); &#125; async destroy () &#123; await super.destroy(ctx); ctx.logger.debug(\"删除\"); &#125;&#125;module.exports = NewsController; 这里第一行也是使用严格模式,提高编译和运行速度 const CommonController = require(&#39;./commonController&#39;); 这是相当于java的导包操作,把commonController引用到当前类中(es6有class的写法) 第五行和java的class写法一样extends也一样表示继承 init() 表示初始化service层(感觉在egg框架还是es6的语法规则中,比如你要调用service层或者你要调用model层的实体的话,都是需要先进行init()进行初始化),虽然这里并没有用到新闻的service层 CRUD(那增加进行举例) 1234async create (ctx) &#123; await super.create(ctx); ctx.logger.debug(\"增加\"); &#125; async 表示使用异步的方式,await表示必须等到suoer.create的返回值在进行下一步在下面就是日志记录 4.简单介绍一下service层的写法 虽然简单的CURD我是基于现成的类进行编写的(在框架整合了简单的curd),但是在真实的业务情况中这些简单的CURD肯定是无法满足业务需求的,所以这里需要新的service层下面是例子 12345678910'use strict';const DaoService = require('./daoService');class NewsService extends DaoService&#123; init() &#123; this.model = this.ctx.model.News; &#125;&#125;module.exports = NewsService; 这里还是要先进行init()方法初始化 自定义的方法编写到daoService 中,这里进行引用应该就可以了 5.处理路由router.js 路由还是比较简单的,但是我觉得还是重要 下面是路由配置 123456789101112131415'use strict';const api = '/api/v1';/** * @param &#123;Egg.Application&#125; app - egg application */module.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; router.post(api + '/surveyRecords/search', controller.surveyRecords.index); router.get(api + '/surveyRecords/exportRecord', controller.surveyRecords.exportRecord); router.resources('surveyRecords', api + '/surveyRecords', controller.surveyRecords); // 角色 router.post(api + '/roles/search', controller.roles.index); router.resources('roles', api + '/roles', controller.roles); router.resources('news', api + '/news', controller.news);&#125;; 这里一样是使用严格模式 const api = &#39;/api/v1&#39; 规定请求路径 module.exports = app =&gt; {} 标准写法 const { router, controller } = app; 这个应该也是标准写法 router.post(api + &#39;/surveyRecords/search&#39;, controller.surveyRecords.index);这个是post请求到controller文件夹下的surveyRecords.js文件中的index方法 router.resources(&#39;news&#39;, api + &#39;/news&#39;, controller.news);这个是整合了post啊get啊那些的RESTful风格,可以根据你的请求进行自动访问规定的方法 0X04接口分析(居家养老服务管理系统)0.登录接口A. 路由 router.get(api + ‘/users/login’, controller.users.login); B. Controller层代码1234567891011121314151617181920async login(ctx) &#123; //从ctx 获取当前GET请求的参数。 const user = await this.service.users.login(ctx.query.phone, ctx.query.password); if (user &amp;&amp; user.roles) &#123; user.permissions = &#123;&#125;; const allPromise = Object.keys(user.roles).map(async s =&gt; &#123; if (Array.isArray(user.roles[s])) &#123; const roles = await this.getRolesBySystem(user.roles, s); user.permissions[s] = roles; &#125; else &#123; for (const orgId of Object.keys(user.roles[s])) &#123; const roles = await this.getRolesBySystemOrg(user.roles, s, orgId); user.permissions[s] = &#123;[orgId]: roles&#125;; &#125; &#125; &#125;); await Promise.all(allPromise); &#125; ctx.body = user;&#125; if (user &amp;&amp; user.roles)user不为空,user.roles不为空 Object.keys()返回一个数组 if (Array.isArray(user.roles[s]))判断是不是数组 getRolesBySystem() C. Service层代码中的login()方法12345678async login(phone, password) &#123; const md5Pass = this.ctx.helper.md5(password); const queries = &#123; $or: [&#123;phone&#125;, &#123;shortName: phone&#125;], password: md5Pass, &#125;; return await this.model.findOne(queries).lean();&#125; 1.通过controller层的const user = await this.service.users.login(ctx.query.phone, ctx.query.password);调用到service层来 2.const md5Pass = this.ctx.helper.md5(password);调用help层(相当于java的util)进行MD5处理 3.$or是个重点,这里举一个官方例子: 1db.inventory.find( &#123; $or: [ &#123; quantity: &#123; $lt: 20 &#125; &#125;, &#123; price: 10 &#125; ] &#125; ) 意思是取出inventory(存货) 集合,条件在$or中分别有两个条件,第一个是quantity字段的值小于20或者price字段等于10,$lt的意思就是小于某个值(以后会有更详细的文章来介绍MongoDB的语法) 4.$or: [{phone}, {shortName: phone}], password: md5Pass先来大概分析这句的意思,肯定有两个条件$or中是一个条件,逗号后面是一个条件。在来分析$or中的条件,$or肯定是有两个条件,系统可以用两种账号来进行登录,第一个种是手机也就是phone字段,第二种是短命登录也就是shortName字段,{phone}相当于{phone:phone},我猜测用{phone}简写是因为在数据库的字段和这里的字段是一样的。第一个条件就分析完了，在来分析第二个条件也就是password: md5Pass这个没有$or说明这个值是一个必须满足的条件。最后在梳理一下，假如传入参数为phone=110,password=123，那么这条语句的意思是在数据库中查找phone字段等于110，或者shortName字段等于110，同时满足password字段=123 5.return await this.model.findOne(queries).lean();model层的实体都有一些默认的方法，findOne()就是其中一个，这里传入的参数就是上面拼接的MongoDB数据库语句 6.lean()这里单独说一下lean()，不加这个方法的话他返回的对象中就带有model的一些默认方法,所以要加这个方法 getRolesBySystem()方法123456async getRolesBySystem(userRoles, system) &#123; const searchParams = &#123;system, name: &#123;$in: userRoles[system]&#125;&#125;; const roles = await this.service.roles.find(searchParams); const results = roles.map(a =&gt; (&#123;[a.name]: a.permission&#125;)).reduce((a, b) =&gt; (&#123;...a, ...b&#125;), &#123;&#125;); return results;&#125; 接收到传入的userRoles数组 和system(相当于Key)","categories":[],"tags":[{"name":"EGG","slug":"EGG","permalink":"http://yoursite.com/tags/EGG/"}]}]}