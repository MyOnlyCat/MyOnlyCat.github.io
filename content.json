{"meta":{"title":"Aurora","subtitle":"","description":"成长","author":"Pock","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-07-12T09:43:48.000Z","updated":"2018-07-13T06:08:54.225Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-07-13T03:25:33.000Z","updated":"2018-07-13T06:09:12.148Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ubuntu下安装mysql-5.7","slug":"ubuntu下安装mysql-5.7","date":"2018-07-19T02:19:55.000Z","updated":"2018-07-19T04:03:03.038Z","comments":true,"path":"2018/07/19/ubuntu下安装mysql-5.7/","link":"","permalink":"http://yoursite.com/2018/07/19/ubuntu下安装mysql-5.7/","excerpt":"今天看我盟哥在搭建到耍我也耍一哈,顺便记录下","text":"今天看我盟哥在搭建到耍我也耍一哈,顺便记录下 0X00 第一步 sudo apt-get install mysql-server会安装以下依赖:apparmormysql-client-5.7mysql-commonmysql-servermysql-server-5.7mysql-server-core-5.7 无需再安装mysql-client等,安装过程会提示输入用户名,输入完毕回车,如下 输入完毕会提示输入用户密码,输入完毕回车,如下 0X01 安装完成 查看是mysql是否占用端口,处于 LISTEN 说明就OK了(类似于看是否启动) ‘sudo netstat -tap | grep mysql’ 0X02 localhost登录mysql服务 本机登录测试 (这里root是你的用户名) ‘mysql -u root -p’ 0X03 常见命令 开启mysql service mysql start关闭mysql service mysql stop重启mysql service mysql restart 0X04 常用配置1. 允许远程访问 首先修改文件 sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf 需要修改的地方在第43行左右点击i进入编辑模式,编辑完按esc退出编辑模式,在按shift加冒号(shift + :),输入wq保存退出 保存退出,执行授权命令：进入mysql服务mysql -u root -p, 执行grant all on *.* to root@&#39;%&#39; identified by &#39;你的密码&#39; with grant option;(记住复制分号,意思是赋予任何主机访问数据库权限)刷新flush privileges;(记住复制分号) 然后执行quit命令退出mysql服务，执行如下命令重启mysql： service mysql restart #重启mysql可能会叫你输入用户密码(不是mysql的密码,你是登录服务器的密码) 测试连接 2. 添加远程用户 输入以下命令 mysql -u root -p #进入mysqlgrant all on *.* to pock@&#39;%&#39; identified by &#39;123456&#39;; #添加一个用户名为pock 密码为123456的用户flush privileges; #刷新配置输入quit退出mysqlservice mysql restart #重启mysql 如果遇到新添加的远程用户无法登录的情况进入mysql输入以下命令 grant all privileges on . to root@’%’ identified by “root用户的密码”; 修改远程用户密码 mysql -u root -p #进入mysqluse mysql; 使用用户表update user set password=password(&#39;新密码&#39;) where user=&#39;需要修改的用户&#39;;flush privileges;刷新配置 0X05 安全配置防火墙不多说配置账号权限 禁止root账号远程登录 update user set host = &quot;localhost&quot; where user = &quot;root&quot; and host= &quot;%&quot;; flush privileges; 禁止项目用户的账号远程登录（项目配置文件） update user set host = &quot;localhost&quot; where user = &quot;web_user&quot; and host= &quot;%&quot;;flush privileges; 同时绑定该账号只允许内网访问（如内网IP：172.19.230.1） update user set host = &quot;172.19.230.1&quot; where user = &quot;web_user&quot; and host= &quot;localhost&quot;;flush privileges; 通过内网连接数据 mysql -h 172.19.230.1 -u web_user -p 针对远程需要登录的可以重新新建一个用户用于远程连接数据库 grant all on *.* to yc_user@&#39;%&#39; identified by &#39;yc123456&#39; with grant option;flush privileges; 说一下where user = “web_user” web_user的权限分类 1.root 禁止远程访问2.web_user 只允许内网访问，该用户暴露在项目代码中3.yc_user 可以远程访问，该用户不应该暴露在项目代码中 0X06 服务管理 不建议用chkconfig,这里使用`sysv-rc-conf 安装sysv-rc-conf sudo apt-get install sysv-rc-conf 直接加入启动程序，例如把 /etc/init.d/mysql 加入到系统自动 启动列表中： sudo sysv-rc-conf mysql on #开启sudo sysv-rc-conf mysql off #关闭 直接使用 sysv-rc-conf 来管理安装命令如下: sudo sysv-rc-conf 界面如下: 介绍下快捷键 使用空格键可以在on和off之间切换+号可以启动服务-号可以停止服务ctrl + n 翻到下一页ctrl + p 翻到上一页h可以查看帮助q退出 介绍下级别(运行级别的详情不太懂) 0 停机 1 单用户，Does not configure network interfaces, start daemons, or allow non-root logins 2 多用户，无网络连接 Does not configure network interfaces or start daemons 3 多用户，启动网络连接 Starts the system normally. 4 用户自定义 5 多用户带图形界面 6 重启","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"}]},{"title":"无工具破解开机密码","slug":"无工具破解开机密码","date":"2018-07-18T08:13:16.000Z","updated":"2018-07-18T09:52:18.329Z","comments":true,"path":"2018/07/18/无工具破解开机密码/","link":"","permalink":"http://yoursite.com/2018/07/18/无工具破解开机密码/","excerpt":"经常忘记怎么无工具这里整理下","text":"经常忘记怎么无工具这里整理下 0X00 Win7下绕过 win7开机绕圈圈的时候一直按住开机键,强制关机 重复启动直到出现启动修复的界面 点启动修复 等待修复失败,点击查看问题详情 点击下面的 然后打开 到windows/System32目录下(记住选择文件类型为所有)把Utilman重命名为Utilman1,在把cmd重命名为Utilman 依次关闭窗口(记得点取消) 开机开机过后按5次shift弹出cmd输入 net user 你想要修改的用户名 你想要的密码 0X01 Win10下绕过 win10开机绕圈圈的时候一直按住开机键,强制关机 重复强制关机一直到自动修复 出现下图时，选择“疑难解答”: 出现下图时，选择“高级选项”: 出现下图时，选择“命令提示符”： 进入CMD 进入CMD过后应该是在X盘,一个隐藏盘吧应该是 直接输入 c:,进入C盘 输入cd Windows\\System32 进入System32目录 输入ren sethc.exe AAA.exe 把沾滞建重命名 输入ren cmd.exe sethc.exe 把cmd替换为sethc.exe 退出重启 开机开机过后按5次shift弹出cmd输入 net user 你想要修改的用户名 你想要的密码","categories":[{"name":"杂项","slug":"杂项","permalink":"http://yoursite.com/categories/杂项/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://yoursite.com/tags/杂项/"}]},{"title":"EGG框架在用forEach或者Map进行遍历调用async方法问题","slug":"EGG框架在用forEach或者Map进行遍历调用async方法问题","date":"2018-07-04T02:20:50.000Z","updated":"2018-07-18T09:27:38.204Z","comments":true,"path":"2018/07/04/EGG框架在用forEach或者Map进行遍历调用async方法问题/","link":"","permalink":"http://yoursite.com/2018/07/04/EGG框架在用forEach或者Map进行遍历调用async方法问题/","excerpt":"EGG框架在用forEach或者Map进行遍历调用async方法问题","text":"EGG框架在用forEach或者Map进行遍历调用async方法问题 0X00 出现的情况12345//假设 newList为一个array类型,这段代码处于async中newList.forEach(x =&gt; x&#123; //这里的的await 会报错,如果不用await这里返回的y就是一个promise对象对于我这种入门的人不太好处理 var y = await this.model.show();&#125;) 0X01 我的解决方法12345//假设 newList为一个array类型,这段代码处于async中for(let i = 0; i &lt; newList.length; i++) &#123; //这里再来调用async方法,这里await方法不会报错,返回的y也是对的 var y = await this.model.show();&#125;","categories":[{"name":"EGG","slug":"EGG","permalink":"http://yoursite.com/categories/EGG/"}],"tags":[{"name":"EGG","slug":"EGG","permalink":"http://yoursite.com/tags/EGG/"}]},{"title":"Git整理","slug":"Git整理","date":"2018-06-13T03:16:19.000Z","updated":"2018-07-18T09:27:26.676Z","comments":true,"path":"2018/06/13/Git整理/","link":"","permalink":"http://yoursite.com/2018/06/13/Git整理/","excerpt":"记录一下容易忘记的GIT命令","text":"记录一下容易忘记的GIT命令 创建SSH Keys 输入指令，进入.ssh文件夹 cd ~/.ssh/如果提示 “ No such file or directory”，你可以手动的创建一个 .ssh文件夹即可 配置全局的name和email，这里是的你github或者bitbucket的name和email git config –global user.name “pockadmin” git config –global user.email “pockadmin@163.com“ 生成key ssh-keygen -t rsa -C “pockadmin@163.com” 连续按三次回车，这里设置的密码就为空了，并且创建了key。 打开Admin目录进入.ssh文件夹，用记事本打开id_rsa.pub，复制里面的内容添加到你github或者bitbucket ssh设置里即可","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"EGG 入门笔记","slug":"EGG 入门笔记","date":"2018-06-04T08:13:37.000Z","updated":"2018-07-19T07:06:17.079Z","comments":true,"path":"2018/06/04/EGG 入门笔记/","link":"","permalink":"http://yoursite.com/2018/06/04/EGG 入门笔记/","excerpt":"EGG框架快速上手","text":"EGG框架快速上手 0X00 这里基于我的情况,需要快速上手 0X01 基于Egg框架的项目启动 找到目录中的package.json,点击右键show npm scripts ,然后dev run,dev run是属于在测试环境中的模式,如果在win环境下跑run的话会出现好多窗口,是因为有多少启动了多个线程,就出现了那么多的窗口 0X02 Egg基本目录结构 controller文件夹和java的一样 extent 属于可选的,可以对框架进行扩展配置,详情见框架扩展 model 是属于Egg的自定义目录规范,详情Loader API public 属于可选,放置静态文件,详情egg-static service 和java的service层一样 router.js 这个主要是路由的配置,相当于servlet配置映射的路径,这个还是比较重要的 0X03 基于RESTful风格的简单的CURD0.Egg中规定的RESTful的请求 ctx的含义 ctx - 当前请求的 Context 实例。 Egg中规定的RESTful的请求 1.简述思路 这里举一个新闻的例子,对新闻进行CURD操作,从model层开始编写,在编写controller层,最后在配置路由router.js配置出RESTful风格的接口(这里不用编写service层是因为我controller继承了一个公共类,其中有最基础的CURD方法,所以说这次上手还是感觉比较简单) 2.Model层的编写,实体的写法 下面是一个新闻的实体 12345678910111213141516'use strict';module.exports = app =&gt; &#123; const mongoose = app.mongoose; const tempSchema = new mongoose.Schema(&#123; _id: mongoose.Schema.Types.ObjectId, tile: String, //标题 content: String, //内容 intro: String, //简介 creation: Number, //创建时间 updated: Number, //更新时间 &#125;, &#123; versionKey: false, &#125;); return mongoose.model('news', tempSchema);&#125;; use strict 表示使用严格模式为什么用严格模式 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 app.mongoose 调用mnogoDB插件 const tempSchema 表示mnogoDB的数据库类型?(暂时不确定,没有使用过mnogoDB) 5到10行就是字段 versionKey: false, 这个一个是个标准的写法吧 return mongoose.model(&#39;news&#39;, tempSchema); 这个可以对应到service层 3.编写Controller层 下面的新闻的controller 123456789101112131415161718192021222324252627282930313233343536373839'use strict';const CommonController = require('./commonController');class NewsController extends CommonController&#123; init() &#123; this.daoService = this.service.news; &#125; async create (ctx) &#123; await super.create(ctx); ctx.logger.debug(\"增加\"); &#125; async show (ctx) &#123; await super.show(ctx); ctx.logger.debug(\"根据ID展示\"); &#125; async index (ctx) &#123; await super.index(ctx); ctx.logger.debug(\"展示所有\"); &#125; async update (ctx) &#123; await super.update(ctx); ctx.logger.debug(\"更新\"); &#125; async destroy () &#123; await super.destroy(ctx); ctx.logger.debug(\"删除\"); &#125;&#125;module.exports = NewsController; 这里第一行也是使用严格模式,提高编译和运行速度 const CommonController = require(&#39;./commonController&#39;); 这是相当于java的导包操作,把commonController引用到当前类中(es6有class的写法) 第五行和java的class写法一样extends也一样表示继承 init() 表示初始化service层(感觉在egg框架还是es6的语法规则中,比如你要调用service层或者你要调用model层的实体的话,都是需要先进行init()进行初始化),虽然这里并没有用到新闻的service层 CRUD(那增加进行举例) 1234async create (ctx) &#123; await super.create(ctx); ctx.logger.debug(\"增加\"); &#125; async 表示使用异步的方式,await表示必须等到suoer.create的返回值在进行下一步在下面就是日志记录 4.简单介绍一下service层的写法 虽然简单的CURD我是基于现成的类进行编写的(在框架整合了简单的curd),但是在真实的业务情况中这些简单的CURD肯定是无法满足业务需求的,所以这里需要新的service层下面是例子 12345678910'use strict';const DaoService = require('./daoService');class NewsService extends DaoService&#123; init() &#123; this.model = this.ctx.model.News; &#125;&#125;module.exports = NewsService; 这里还是要先进行init()方法初始化 自定义的方法编写到daoService 中,这里进行引用应该就可以了 5.处理路由router.js 路由还是比较简单的,但是我觉得还是重要 下面是路由配置 123456789101112131415'use strict';const api = '/api/v1';/** * @param &#123;Egg.Application&#125; app - egg application */module.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; router.post(api + '/surveyRecords/search', controller.surveyRecords.index); router.get(api + '/surveyRecords/exportRecord', controller.surveyRecords.exportRecord); router.resources('surveyRecords', api + '/surveyRecords', controller.surveyRecords); // 角色 router.post(api + '/roles/search', controller.roles.index); router.resources('roles', api + '/roles', controller.roles); router.resources('news', api + '/news', controller.news);&#125;; 这里一样是使用严格模式 const api = &#39;/api/v1&#39; 规定请求路径 module.exports = app =&gt; {} 标准写法 const { router, controller } = app; 这个应该也是标准写法 router.post(api + &#39;/surveyRecords/search&#39;, controller.surveyRecords.index);这个是post请求到controller文件夹下的surveyRecords.js文件中的index方法 router.resources(&#39;news&#39;, api + &#39;/news&#39;, controller.news);这个是整合了post啊get啊那些的RESTful风格,可以根据你的请求进行自动访问规定的方法 0X04接口分析(居家养老服务管理系统)0.登录接口A. 路由 router.get(api + ‘/users/login’, controller.users.login); B. Controller层代码1234567891011121314151617181920async login(ctx) &#123; //从ctx 获取当前GET请求的参数。 const user = await this.service.users.login(ctx.query.phone, ctx.query.password); if (user &amp;&amp; user.roles) &#123; user.permissions = &#123;&#125;; const allPromise = Object.keys(user.roles).map(async s =&gt; &#123; if (Array.isArray(user.roles[s])) &#123; const roles = await this.getRolesBySystem(user.roles, s); user.permissions[s] = roles; &#125; else &#123; for (const orgId of Object.keys(user.roles[s])) &#123; const roles = await this.getRolesBySystemOrg(user.roles, s, orgId); user.permissions[s] = &#123;[orgId]: roles&#125;; &#125; &#125; &#125;); await Promise.all(allPromise); &#125; ctx.body = user;&#125; if (user &amp;&amp; user.roles)user不为空,user.roles不为空 Object.keys()返回一个数组 if (Array.isArray(user.roles[s]))判断是不是数组 getRolesBySystem() C. Service层代码中的login()方法12345678async login(phone, password) &#123; const md5Pass = this.ctx.helper.md5(password); const queries = &#123; $or: [&#123;phone&#125;, &#123;shortName: phone&#125;], password: md5Pass, &#125;; return await this.model.findOne(queries).lean();&#125; 1.通过controller层的const user = await this.service.users.login(ctx.query.phone, ctx.query.password);调用到service层来 2.const md5Pass = this.ctx.helper.md5(password);调用help层(相当于java的util)进行MD5处理 3.$or是个重点,这里举一个官方例子: 1db.inventory.find( &#123; $or: [ &#123; quantity: &#123; $lt: 20 &#125; &#125;, &#123; price: 10 &#125; ] &#125; ) 意思是取出inventory(存货) 集合,条件在$or中分别有两个条件,第一个是quantity字段的值小于20或者price字段等于10,$lt的意思就是小于某个值(以后会有更详细的文章来介绍MongoDB的语法) 4.$or: [{phone}, {shortName: phone}], password: md5Pass先来大概分析这句的意思,肯定有两个条件$or中是一个条件,逗号后面是一个条件。在来分析$or中的条件,$or肯定是有两个条件,系统可以用两种账号来进行登录,第一个种是手机也就是phone字段,第二种是短命登录也就是shortName字段,{phone}相当于{phone:phone},我猜测用{phone}简写是因为在数据库的字段和这里的字段是一样的。第一个条件就分析完了，在来分析第二个条件也就是password: md5Pass这个没有$or说明这个值是一个必须满足的条件。最后在梳理一下，假如传入参数为phone=110,password=123，那么这条语句的意思是在数据库中查找phone字段等于110，或者shortName字段等于110，同时满足password字段=123 5.return await this.model.findOne(queries).lean();model层的实体都有一些默认的方法，findOne()就是其中一个，这里传入的参数就是上面拼接的MongoDB数据库语句 6.lean()这里单独说一下lean()，不加这个方法的话他返回的对象中就带有model的一些默认方法,所以要加这个方法 getRolesBySystem()方法123456async getRolesBySystem(userRoles, system) &#123; const searchParams = &#123;system, name: &#123;$in: userRoles[system]&#125;&#125;; const roles = await this.service.roles.find(searchParams); const results = roles.map(a =&gt; (&#123;[a.name]: a.permission&#125;)).reduce((a, b) =&gt; (&#123;...a, ...b&#125;), &#123;&#125;); return results;&#125; 接收到传入的userRoles数组 和system(相当于Key)","categories":[{"name":"EGG","slug":"EGG","permalink":"http://yoursite.com/categories/EGG/"}],"tags":[{"name":"EGG","slug":"EGG","permalink":"http://yoursite.com/tags/EGG/"}]},{"title":"IDEA处理非SpringBoot的启动方法","slug":"IDEA处理非SpringBoot的启动方法","date":"2018-05-18T03:09:29.000Z","updated":"2018-07-18T10:09:28.041Z","comments":true,"path":"2018/05/18/IDEA处理非SpringBoot的启动方法/","link":"","permalink":"http://yoursite.com/2018/05/18/IDEA处理非SpringBoot的启动方法/","excerpt":"记录下配置非SpringBoot的问题","text":"记录下配置非SpringBoot的问题 1. 2. 3. 4.启动在试试启动","categories":[{"name":"IDEA","slug":"IDEA","permalink":"http://yoursite.com/categories/IDEA/"}],"tags":[{"name":"IDEA,","slug":"IDEA","permalink":"http://yoursite.com/tags/IDEA/"},{"name":"疑难杂症","slug":"疑难杂症","permalink":"http://yoursite.com/tags/疑难杂症/"}]},{"title":"HEXO博客搭建的坑","slug":"HEXO博客搭建的坑","date":"2018-05-18T02:37:28.000Z","updated":"2018-07-18T09:51:46.099Z","comments":true,"path":"2018/05/18/HEXO博客搭建的坑/","link":"","permalink":"http://yoursite.com/2018/05/18/HEXO博客搭建的坑/","excerpt":"记录下第二次搭建博客的流程","text":"记录下第二次搭建博客的流程 前景 原来的博客换了电脑就没法更新了,很麻烦,这里我使用分支的方式进行部署,顺便记录一下自己遇到问题 0X00 环境配置 配置nodejs 安装git命令客户端 配置git,命令为 git config --global user.name &quot;你的github名字&quot; , git config --global user.email &quot;你的github邮箱&quot; 0X01 GitHub仓库创建 第一步 第二步 注意这里名字要用自己的GitHub用户名加.github.io,才能让GitHub自动给你分配githubpage 第三步 在仓库里面随便创建一个REMDME文件,方便修改分支 第四步 新建一个分支 设置为默认分支 0X02 配置HEXO 第一步 使用git把你的默认分支clone下来(直接复制地址clone肯定是你的默认分支) 第二步 进入项目目录在git用使用hexo init blog 把blog文件中的东西复制到你的项目目录去(如果blog文件中有.git的话就删除在复制就完了) 第三步 使用github的windows客户端把修改提交到分支 0X03 部署 ‘hexo g’ hexo s //启动本地服务,方便看效果 hexo d //提交到分支了,然后master分支就合并了 上一步可能存在一些问题,我平常更新是结合github的Windows客户端进行提交,也就是我hexo s启动过后看效果,ok的话我就直接用客户端进行上传,上传完成过后访问线上网站并不会更新,我需要点击 这个按钮才会更新线上的(原因我没研究,怪我github用的太少) 0X04 遇到的问题 ERROR Plugin load failed: hexo-server解决: sudo npm install hexo-server hexo-renderer相关的错误解决: npm install hexo-renderer-ejs --save npm install hexo-renderer-stylus --save npm install hexo-renderer-marked --save 这个时候再重新生成静态文件，命令： hexo generate （或hexo g） 启动本地服务器： hexo server （或hexo s）","categories":[{"name":"HEXO","slug":"HEXO","permalink":"http://yoursite.com/categories/HEXO/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"http://yoursite.com/tags/HEXO/"}]},{"title":"我的IDEA常用插件","slug":"我的IDEA常用插件","date":"2018-02-28T01:45:00.000Z","updated":"2018-07-18T10:13:21.320Z","comments":true,"path":"2018/02/28/我的IDEA常用插件/","link":"","permalink":"http://yoursite.com/2018/02/28/我的IDEA常用插件/","excerpt":"记录下使用IDEA开发下常用的插件","text":"记录下使用IDEA开发下常用的插件 CodeGlance 代码预览 Alibaba Java Coding Guidelines 代码审查,根据阿里巴巴Java开发守则 grep-console 日志颜色区分,结合log4j activate-power-mode 写代码时的动画效果 Maven Helper 一旦安装了Maven Helper插件，只要打开pom文件，就可以打开该pom文件的Dependency Analyzer视图（在文件打开之后，文件下面会多出这样一个tab），进入Dependency Analyzer视图之后有三个查看选项，分别是Conflicts(冲突)、All Dependencies as List(列表形式查看所有依赖)、All Dependencies as Tree(树结构查看所有依赖)。并且这个页面还支持搜索。很方便！并且使用该插件还能快速的执行maven命令。 FindBugs 查找BUG Jrebel 热部署插件 类注释模板 File and Code Templates 中设置class 添加模板 12345678910/*** @program: $&#123;PROJECT_NAME&#125;** @description: $&#123;description&#125;** @author: lq** @create: $&#123;YEAR&#125;/$&#123;MONTH&#125;/$&#123;DAY&#125;**/","categories":[{"name":"IDEA","slug":"IDEA","permalink":"http://yoursite.com/categories/IDEA/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://yoursite.com/tags/IDEA/"}]},{"title":"HashMap的负载因子","slug":"HashMap的负载因子","date":"2018-01-22T01:56:00.000Z","updated":"2018-07-18T09:59:16.498Z","comments":true,"path":"2018/01/22/HashMap的负载因子/","link":"","permalink":"http://yoursite.com/2018/01/22/HashMap的负载因子/","excerpt":"学习数据结构的笔记","text":"学习数据结构的笔记 在使用LinkedHashMap时,如下: 12345public class test &#123; public static void main(String[] args) &#123; Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;(); &#125;&#125; 发现LinkedHashMap中的构造方法 1234public LinkedHashMap() &#123; super(); accessOrder = false; &#125; 发现调用的父类HashMap其中的一个构造方法 123public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; 其中的DEFAULT_LOAD_FACTOR常量被设定为0.75,如下 1static final float DEFAULT_LOAD_FACTOR = 0.75f; 这就是HashMap负载因子的默认值 而HashMap的另一个构造函数: 123456789101112131415161718192021/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; 其中有两个参数initialCapacity和loadFactor initialCapacity表示map的初始化容量，initialCapacity &gt; MAXIMUM_CAPACITY，表明map的最大容量是1&lt;&lt;30,也就是1左移30位，每左移一位乘以2，所以就是1*2^30=1073741824 loadFactor是map的负载因子,loadFactor &lt;= 0 || Float.isNaN(loadFactor),表明负载因子要大于0，且是非无穷大的数字 负载因子为什么会影响HashMap的性能? 这里借用sxlzs_博主的解释 我们都知道有序数组存储数据，对数据的索引效率都很高，但是插入和删除就会有性能瓶颈（回忆ArrayList）， 链表存储数据，要一次比较元素来检索出数据，所以索引效率低，但是插入和删除效率高（回忆LinkedList）， 两者取长补短就产生了哈希散列这种存储方式，也就是HashMap的存储逻辑. 而负载因子表示一个散列表的空间的使用程度，有这样一个公式：initailCapacity*loadFactor=HashMap的容量。 所以负载因子越大则散列表的装填程度越高，也就是能容纳更多的元素，元素多了，链表大了，所以此时索引效率就会降低。 反之，负载因子越小则链表中的数据量就越稀疏，此时会对空间造成烂费，但是此时索引效率高。 如何科学的设置initailCapacity,loadFactor的值: HashMap有三个构造函数，可以选用无参构造函数，不进行设置。默认值分别是16和0.75 官方的建议是initailCapacity设置成2的n次幂，laodFactor根据业务需求，如果迭代性能不是很重要，可以设置大一下。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"HashMap","slug":"HashMap","permalink":"http://yoursite.com/tags/HashMap/"}]},{"title":"JavaFx苦逼之路","slug":"JavaFx爬坑之旅","date":"2018-01-12T01:42:00.000Z","updated":"2018-07-18T10:15:40.156Z","comments":true,"path":"2018/01/12/JavaFx爬坑之旅/","link":"","permalink":"http://yoursite.com/2018/01/12/JavaFx爬坑之旅/","excerpt":"啊啊啊,JavaFX贼难玩,不喜欢","text":"啊啊啊,JavaFX贼难玩,不喜欢 前言目前我能用javafx做的东西都很少,还跟在大佬屁股后面学习.说不定写着写着就脱坑停更! 绑定tableView 需求是绑定几个测试参数到tableView下如图 结构为:tabPane -&gt; Tab -&gt; tableView -&gt; 若干个TableColumn 第一步先设置fx:idtableView上肯定需要fx:id,然后在给每一列绑定fx:id,如下图 第二步,编写相关联的实体由于我的tableview中显示的数据封装在了实体类中,所以这里我们需要先定义实体,实体的定义如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137import javafx.beans.property.DoubleProperty;import javafx.beans.property.IntegerProperty;import javafx.beans.property.SimpleDoubleProperty;import javafx.beans.property.StringProperty;/** * 限价委托实体类 */public class LimitEntrustEntity extends Commission&#123; private DoubleProperty orderState = new SimpleDoubleProperty(); //已成交数量 private DoubleProperty priceOfOrder = new SimpleDoubleProperty(); //成交均价 private DoubleProperty gvm = new SimpleDoubleProperty(); //成交总额 public LimitEntrustEntity(DoubleProperty orderState, DoubleProperty priceOfOrder, DoubleProperty gvm) &#123; this.orderState = orderState; this.priceOfOrder = priceOfOrder; this.gvm = gvm; &#125; public LimitEntrustEntity() &#123; &#125; public double getOrderState() &#123; return orderState.get(); &#125; public DoubleProperty orderStateProperty() &#123; return orderState; &#125; public void setOrderState(double orderState) &#123; this.orderState.set(orderState); &#125; public double getPriceOfOrder() &#123; return priceOfOrder.get(); &#125; public DoubleProperty priceOfOrderProperty() &#123; return priceOfOrder; &#125; public void setPriceOfOrder(double priceOfOrder) &#123; this.priceOfOrder.set(priceOfOrder); &#125; public double getGvm() &#123; return gvm.get(); &#125; public DoubleProperty gvmProperty() &#123; return gvm; &#125; public void setGvm(double gvm) &#123; this.gvm.set(gvm); &#125; @Override public double getCommissionQty() &#123; return super.getCommissionQty(); &#125; @Override public DoubleProperty commissionQtyProperty() &#123; return super.commissionQtyProperty(); &#125; @Override public void setCommissionQty(double commissionQty) &#123; super.setCommissionQty(commissionQty); &#125; @Override public double getCommissionTime() &#123; return super.getCommissionTime(); &#125; @Override public DoubleProperty commissionTimeProperty() &#123; return super.commissionTimeProperty(); &#125; @Override public void setCommissionTime(double commissionTime) &#123; super.setCommissionTime(commissionTime); &#125; @Override public double getCommissionPrice() &#123; return super.getCommissionPrice(); &#125; @Override public DoubleProperty commissionPriceProperty() &#123; return super.commissionPriceProperty(); &#125; @Override public void setCommissionPrice(double commissionPrice) &#123; super.setCommissionPrice(commissionPrice); &#125; @Override public int getState() &#123; return super.getState(); &#125; @Override public IntegerProperty stateProperty() &#123; return super.stateProperty(); &#125; @Override public void setState(int state) &#123; super.setState(state); &#125; @Override public String getOrderSource() &#123; return super.getOrderSource(); &#125; @Override public StringProperty orderSourceProperty() &#123; return super.orderSourceProperty(); &#125; @Override public void setOrderSource(String orderSource) &#123; super.setOrderSource(orderSource); &#125;&#125; 这里我继承了父类,父类如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.yczr.threebody.pc.entity;import javafx.beans.property.*;import java.io.Serializable;public class Commission implements Serializable &#123; private DoubleProperty commissionQty = new SimpleDoubleProperty(); //委托数量 2 private DoubleProperty commissionTime = new SimpleDoubleProperty(); //委托时间 2// private DoubleProperty triggerPrice; //触发价格 1 private DoubleProperty commissionPrice = new SimpleDoubleProperty(); //委托价格 2// private TradeStatus realTriggerPrice; //真实触发价 1 private IntegerProperty state = new SimpleIntegerProperty(); //状态 2 private StringProperty orderSource = new SimpleStringProperty(); //订单来源 2 public double getCommissionQty() &#123; return commissionQty.get(); &#125; public DoubleProperty commissionQtyProperty() &#123; return commissionQty; &#125; public void setCommissionQty(double commissionQty) &#123; this.commissionQty.set(commissionQty); &#125; public double getCommissionTime() &#123; return commissionTime.get(); &#125; public DoubleProperty commissionTimeProperty() &#123; return commissionTime; &#125; public void setCommissionTime(double commissionTime) &#123; this.commissionTime.set(commissionTime); &#125;// public double getTriggerPrice() &#123;// return triggerPrice.get();// &#125;//// public DoubleProperty triggerPriceProperty() &#123;// return triggerPrice;// &#125;//// public void setTriggerPrice(double triggerPrice) &#123;// this.triggerPrice.set(triggerPrice);// &#125; public double getCommissionPrice() &#123; return commissionPrice.get(); &#125; public DoubleProperty commissionPriceProperty() &#123; return commissionPrice; &#125; public void setCommissionPrice(double commissionPrice) &#123; this.commissionPrice.set(commissionPrice); &#125; public int getState() &#123; return state.get(); &#125; public IntegerProperty stateProperty() &#123; return state; &#125; public void setState(int state) &#123; this.state.set(state); &#125; public String getOrderSource() &#123; return orderSource.get(); &#125; public StringProperty orderSourceProperty() &#123; return orderSource; &#125; public void setOrderSource(String orderSource) &#123; this.orderSource.set(orderSource); &#125;&#125; 顺便说一下这里遇到的坑!!!!! 定义需要绑定的值时,属性还是用的以前的类型,比如Double类型还是用的Double,但是在javafx中Double变为了javafx中的封装类型DoubleProperty,其它的数据类型应该也是这样; 实体类我用的随机数进行赋值,代码如下: 1234567891011121314151617181920212223public static Double getRandom(int max)&#123; double v = new Random(max).nextDouble(); return v; &#125; public static Double getRandom()&#123; Double random = getRandom(1000); return random; &#125; public static LimitEntrustEntity getLeEntity() &#123; LimitEntrustEntity leEntity = new LimitEntrustEntity(); leEntity.setCommissionPrice(getRandom()); leEntity.setCommissionQty(getRandom()); leEntity.setCommissionTime(getRandom()); leEntity.setGvm(getRandom()); leEntity.setOrderSource(getRandom().toString()); leEntity.setOrderState(getRandom()); leEntity.setPriceOfOrder(getRandom()); leEntity.setState(getRandom().intValue()); return leEntity; &#125; 其中的坑是真的多!,我没有没父类Commission中的属性设置默认值,导致加载数据时为空 第三步,在代码中与fx:id绑定虽然在fxml文件中设置了fx:id,但是在实际的程序中并没有做任何相关联的绑定,所以这一步就需要进行相关的绑定; 定义数据源 1private ObservableList&lt;TradeOverviewEntity&gt; exchangeData = FXCollections.observableArrayList(); 绑定TableView 12@FXMLprivate TableView&lt;TradeOverviewEntity&gt; exTable; 绑定列TableColumn 12345678@FXMLprivate TableColumn&lt;TradeOverviewEntity, String&gt; coinName;@FXMLprivate TableColumn&lt;TradeOverviewEntity, Number&gt; exPrice;@FXMLprivate TableColumn&lt;TradeOverviewEntity, Number&gt; exMaxPrice; //..........省略其它列 加载数据 前面虽然绑定了数据源,但是并没有进行实际的赋值,下面先把值和列对应上 12345678910 private void initBean()&#123; lpwtTime.setCellValueFactory(cellData -&gt; cellData.getValue().commissionTimeProperty()); //委托时间 plNumber.setCellValueFactory(cellData -&gt; cellData.getValue().commissionQtyProperty()); //委托数量 plDeal.setCellValueFactory(cellData -&gt; cellData.getValue().orderStateProperty()); //已成交 plPrice.setCellValueFactory(cellData -&gt; cellData.getValue().commissionPriceProperty()); //委托价格 plPrice2.setCellValueFactory(cellData -&gt; cellData.getValue().priceOfOrderProperty()); //成交均价(QC) plTotal.setCellValueFactory(cellData -&gt; cellData.getValue().commissionTimeProperty()); //成交总额(QC) plState.setCellValueFactory(cellData -&gt; cellData.getValue().stateProperty()); //状态 plSource.setCellValueFactory(cellData -&gt; cellData.getValue().orderSourceProperty()); //状态&#125; 对数据进行赋值 123456private void loadData()&#123; //随机生成5个订单 for (int i = 0; i &lt; 5; i++) &#123; limitEntrusData.add(BeanUtils.getLeEntity()); &#125; &#125; 初始化加载数据 1234567@FXMLprivate void initialize() &#123; initBean(); loadData(); lpTable.setItems(limitEntrusData);&#125; 效果 监听TextField变化目的是为了完成界面简单的密码强度判断,如下界面 绑定fxid 其它的fxid就不一一绑定了 编写监听方法123456789101112131415161718192021public void testyy() &#123; password.textProperty().addListener(new ChangeListener&lt;String&gt;() &#123; @Override public void changed(ObservableValue&lt;? extends String&gt; observable, String oldValue, String newValue) &#123; //下面是逻辑处理部分 if (password.getText().equals(\"\") || password.getText().length() &lt; 1) &#123; pwIntensity.setText(\"登录密码不能为空\"); &#125; else &#123; String intensity = null; if (password.getText().length() &gt; 5) &#123; intensity = \"强\"; &#125; else if (password.getText().length() &lt; 5) &#123; intensity = \"弱\"; &#125; else &#123; intensity = \"极强\"; &#125; pwIntensity.setText(\"密码强度\" + intensity); &#125; &#125; &#125;);&#125; 调用监听监听需要在页面初始化的时候就进行加载,所以在initialize()中吊起 1234@FXMLprivate void initialize() &#123; testyy();&#125; 效果","categories":[{"name":"JavaFx","slug":"JavaFx","permalink":"http://yoursite.com/categories/JavaFx/"}],"tags":[{"name":"JavaFx","slug":"JavaFx","permalink":"http://yoursite.com/tags/JavaFx/"}]}]}