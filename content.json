{"meta":{"title":"Aurora","subtitle":"","description":"成长","author":"Pock","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-07-12T09:43:48.000Z","updated":"2018-07-13T06:08:54.225Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-07-13T03:25:33.000Z","updated":"2018-07-13T06:09:12.148Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ubuntu下安装mysql-5.7","slug":"ubuntu下安装mysql-5.7","date":"2018-07-19T02:19:55.000Z","updated":"2018-07-19T04:03:03.038Z","comments":true,"path":"ubuntu下安装mysql-5.7.html","link":"","permalink":"http://yoursite.com/ubuntu下安装mysql-5.7.html","excerpt":"今天看我盟哥在搭建到耍我也耍一哈,顺便记录下","text":"今天看我盟哥在搭建到耍我也耍一哈,顺便记录下 0X00 第一步 sudo apt-get install mysql-server会安装以下依赖:apparmormysql-client-5.7mysql-commonmysql-servermysql-server-5.7mysql-server-core-5.7 无需再安装mysql-client等,安装过程会提示输入用户名,输入完毕回车,如下 输入完毕会提示输入用户密码,输入完毕回车,如下 0X01 安装完成 查看是mysql是否占用端口,处于 LISTEN 说明就OK了(类似于看是否启动) ‘sudo netstat -tap | grep mysql’ 0X02 localhost登录mysql服务 本机登录测试 (这里root是你的用户名) ‘mysql -u root -p’ 0X03 常见命令 开启mysql service mysql start关闭mysql service mysql stop重启mysql service mysql restart 0X04 常用配置1. 允许远程访问 首先修改文件 sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf 需要修改的地方在第43行左右点击i进入编辑模式,编辑完按esc退出编辑模式,在按shift加冒号(shift + :),输入wq保存退出 保存退出,执行授权命令：进入mysql服务mysql -u root -p, 执行grant all on *.* to root@&#39;%&#39; identified by &#39;你的密码&#39; with grant option;(记住复制分号,意思是赋予任何主机访问数据库权限)刷新flush privileges;(记住复制分号) 然后执行quit命令退出mysql服务，执行如下命令重启mysql： service mysql restart #重启mysql可能会叫你输入用户密码(不是mysql的密码,你是登录服务器的密码) 测试连接 2. 添加远程用户 输入以下命令 mysql -u root -p #进入mysqlgrant all on *.* to pock@&#39;%&#39; identified by &#39;123456&#39;; #添加一个用户名为pock 密码为123456的用户flush privileges; #刷新配置输入quit退出mysqlservice mysql restart #重启mysql 如果遇到新添加的远程用户无法登录的情况进入mysql输入以下命令 grant all privileges on . to root@’%’ identified by “root用户的密码”; 修改远程用户密码 mysql -u root -p #进入mysqluse mysql; 使用用户表update user set password=password(&#39;新密码&#39;) where user=&#39;需要修改的用户&#39;;flush privileges;刷新配置 0X05 安全配置防火墙不多说配置账号权限 禁止root账号远程登录 update user set host = &quot;localhost&quot; where user = &quot;root&quot; and host= &quot;%&quot;; flush privileges; 禁止项目用户的账号远程登录（项目配置文件） update user set host = &quot;localhost&quot; where user = &quot;web_user&quot; and host= &quot;%&quot;;flush privileges; 同时绑定该账号只允许内网访问（如内网IP：172.19.230.1） update user set host = &quot;172.19.230.1&quot; where user = &quot;web_user&quot; and host= &quot;localhost&quot;;flush privileges; 通过内网连接数据 mysql -h 172.19.230.1 -u web_user -p 针对远程需要登录的可以重新新建一个用户用于远程连接数据库 grant all on *.* to yc_user@&#39;%&#39; identified by &#39;yc123456&#39; with grant option;flush privileges; 说一下where user = “web_user” web_user的权限分类 1.root 禁止远程访问2.web_user 只允许内网访问，该用户暴露在项目代码中3.yc_user 可以远程访问，该用户不应该暴露在项目代码中 0X06 服务管理 不建议用chkconfig,这里使用`sysv-rc-conf 安装sysv-rc-conf sudo apt-get install sysv-rc-conf 直接加入启动程序，例如把 /etc/init.d/mysql 加入到系统自动 启动列表中： sudo sysv-rc-conf mysql on #开启sudo sysv-rc-conf mysql off #关闭 直接使用 sysv-rc-conf 来管理安装命令如下: sudo sysv-rc-conf 界面如下: 介绍下快捷键 使用空格键可以在on和off之间切换+号可以启动服务-号可以停止服务ctrl + n 翻到下一页ctrl + p 翻到上一页h可以查看帮助q退出 介绍下级别(运行级别的详情不太懂) 0 停机 1 单用户，Does not configure network interfaces, start daemons, or allow non-root logins 2 多用户，无网络连接 Does not configure network interfaces or start daemons 3 多用户，启动网络连接 Starts the system normally. 4 用户自定义 5 多用户带图形界面 6 重启","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"}]},{"title":"无工具破解开机密码","slug":"无工具破解开机密码","date":"2018-07-18T08:13:16.000Z","updated":"2018-07-18T09:52:18.329Z","comments":true,"path":"无工具破解开机密码.html","link":"","permalink":"http://yoursite.com/无工具破解开机密码.html","excerpt":"经常忘记怎么无工具这里整理下","text":"经常忘记怎么无工具这里整理下 0X00 Win7下绕过 win7开机绕圈圈的时候一直按住开机键,强制关机 重复启动直到出现启动修复的界面 点启动修复 等待修复失败,点击查看问题详情 点击下面的 然后打开 到windows/System32目录下(记住选择文件类型为所有)把Utilman重命名为Utilman1,在把cmd重命名为Utilman 依次关闭窗口(记得点取消) 开机开机过后按5次shift弹出cmd输入 net user 你想要修改的用户名 你想要的密码 0X01 Win10下绕过 win10开机绕圈圈的时候一直按住开机键,强制关机 重复强制关机一直到自动修复 出现下图时，选择“疑难解答”: 出现下图时，选择“高级选项”: 出现下图时，选择“命令提示符”： 进入CMD 进入CMD过后应该是在X盘,一个隐藏盘吧应该是 直接输入 c:,进入C盘 输入cd Windows\\System32 进入System32目录 输入ren sethc.exe AAA.exe 把沾滞建重命名 输入ren cmd.exe sethc.exe 把cmd替换为sethc.exe 退出重启 开机开机过后按5次shift弹出cmd输入 net user 你想要修改的用户名 你想要的密码","categories":[{"name":"杂项","slug":"杂项","permalink":"http://yoursite.com/categories/杂项/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://yoursite.com/tags/杂项/"}]},{"title":"SQL注入","slug":"SQL注入的总结","date":"2018-07-04T04:52:31.000Z","updated":"2018-07-20T06:27:05.375Z","comments":true,"path":"SQL注入的总结.html","link":"","permalink":"http://yoursite.com/SQL注入的总结.html","excerpt":"脚本小子之路,嘻嘻嘻","text":"脚本小子之路,嘻嘻嘻 0X00 扫描C段,和端口服务信息 nmap -sV -sT -Pn –open -v 地址或者IP 0X01 简单扫描端口服务信息 nmap -sV 地址或者IP 0X02 检查是否存在常见漏洞 nmap –script=vuln 地址或者IP 0X03 sqlmap默认配置 –batch 从不询问用户输入，使用所有默认配置。 0X04 sqlmap绕过WAF -v 3 –dbs –batch –tamper “space2morehash.py” space2morehash.py中可以替换space2hash.py或者base64encode.py或者charencode.py 都是编码方式 space2hash.py base64encode.py charencode.py 0X05 SQLMAP伪静态注入(1) 查找数据库 -u “http://xxx.cn/index.php/Index/view/id/40.html&quot; –dbs 0X06 SQLMAP注入点执行命令与交互写shell 此处采用的是Linux系统 sqlmap -u [url]http://192.168.159.1/news.php?id=1[/url] –os-cmd=ipconfig 获取shell sqlmap -u [url]http://192.168.159.1/news.php?id=1[/url] –os-shell 0X07 判断网站是否为伪静态 javascript:alert(document.lastModified) 1.弹出的时间和当前时间一样就是静态 2.弹出时间和当前时间不一样说明为伪静态 0X08 MSF连接数据库启用缓存系统 service postgresql start 开启数据库服务 进入MSF过后,输入db_status查看连接状态 重启MSF 0X09 sqlmapHTTP请求延迟避免WAF –delay 每次http(s)请求之间延迟时间，浮点数，单位为妙，默认无延迟，输入此参数，你会发现每个请求都会延迟3秒，当然数据库还是可以爆出来的。","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://yoursite.com/categories/SQL注入/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://yoursite.com/tags/SQL注入/"}]},{"title":"EGG框架在用forEach或者Map进行遍历调用async方法问题","slug":"EGG框架在用forEach或者Map进行遍历调用async方法问题","date":"2018-07-04T02:20:50.000Z","updated":"2018-07-18T09:27:38.204Z","comments":true,"path":"EGG框架在用forEach或者Map进行遍历调用async方法问题.html","link":"","permalink":"http://yoursite.com/EGG框架在用forEach或者Map进行遍历调用async方法问题.html","excerpt":"EGG框架在用forEach或者Map进行遍历调用async方法问题","text":"EGG框架在用forEach或者Map进行遍历调用async方法问题 0X00 出现的情况12345//假设 newList为一个array类型,这段代码处于async中newList.forEach(x =&gt; x&#123; //这里的的await 会报错,如果不用await这里返回的y就是一个promise对象对于我这种入门的人不太好处理 var y = await this.model.show();&#125;) 0X01 我的解决方法12345//假设 newList为一个array类型,这段代码处于async中for(let i = 0; i &lt; newList.length; i++) &#123; //这里再来调用async方法,这里await方法不会报错,返回的y也是对的 var y = await this.model.show();&#125;","categories":[{"name":"EGG","slug":"EGG","permalink":"http://yoursite.com/categories/EGG/"}],"tags":[{"name":"EGG","slug":"EGG","permalink":"http://yoursite.com/tags/EGG/"}]},{"title":"Ubuntu常用命令","slug":"Ubuntu常用命令","date":"2018-06-19T06:03:49.000Z","updated":"2018-07-20T06:47:00.625Z","comments":true,"path":"Ubuntu常用命令.html","link":"","permalink":"http://yoursite.com/Ubuntu常用命令.html","excerpt":"Ubuntu常用命令","text":"Ubuntu常用命令 查看磁盘空间大小命令 df -hl 查看磁盘剩余空间df -h 查看每个根路径的分区大小du -sh [目录名] 返回该目录的大小 du -sh * 查看目录下每个文件夹的大小du -sm [文件夹] 返回该文件夹总M数df –help 查看更多功能 查看文件修改时间（精确到秒） ls –full-time 删除文件 rm [参数] [文件名]-r 就是向下递归，不管有多少级目录，一并删除-f 就是直接强行删除，不作任何提示的意思 修改权限 sudo chown www:www ./ -R","categories":[{"name":"Ubuntu常用命令","slug":"Ubuntu常用命令","permalink":"http://yoursite.com/categories/Ubuntu常用命令/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"}]},{"title":"Git整理","slug":"Git整理","date":"2018-06-13T03:16:19.000Z","updated":"2018-07-18T09:27:26.676Z","comments":true,"path":"Git整理.html","link":"","permalink":"http://yoursite.com/Git整理.html","excerpt":"记录一下容易忘记的GIT命令","text":"记录一下容易忘记的GIT命令 创建SSH Keys 输入指令，进入.ssh文件夹 cd ~/.ssh/如果提示 “ No such file or directory”，你可以手动的创建一个 .ssh文件夹即可 配置全局的name和email，这里是的你github或者bitbucket的name和email git config –global user.name “pockadmin” git config –global user.email “pockadmin@163.com“ 生成key ssh-keygen -t rsa -C “pockadmin@163.com” 连续按三次回车，这里设置的密码就为空了，并且创建了key。 打开Admin目录进入.ssh文件夹，用记事本打开id_rsa.pub，复制里面的内容添加到你github或者bitbucket ssh设置里即可","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"MongoDB整理","slug":"MongoDB整理","date":"2018-06-13T02:16:28.000Z","updated":"2018-07-20T03:42:26.491Z","comments":true,"path":"MongoDB整理.html","link":"","permalink":"http://yoursite.com/MongoDB整理.html","excerpt":"初学MongoDB记录下遇见的语句","text":"初学MongoDB记录下遇见的语句 常用语句db.businesorders.find().pretty() 查看某个数据库的数据 $gte, $gt, $lte, $lt $gte 大于等于, $gt 大于, $lte小于等于, $lt小于 $match 比如说我查询之前需要根据时间筛选一次就需要这个,下面是例子 1&#123;$match : &#123;'created' : &#123;$gte : 1527782400000,$lte : 1530374400000&#125;&#125;&#125; $group 分组 { $group: { _id: , : { : }, … } } 第一个字段必须是_id,对应的就是分类的字段,field随便取 展示所有table show tables $skip,$limit 分页语句,下面是例子 1234567//$skip 跳过前面的数据 from就是前面几页的数据//$limit 和mysql一样const page = Number(pagin.page || 1);const pageSize = Number(pagin.pageSize || 10);const from = (page - 1) * pageSize;&#123; $skip: from &#125;,&#123; $limit: pageSize &#125;, $unwind 用来处理数组,下面举例 service 这里为数组结构,我分组的时候需要用某个service中的字段进行$$group,但是数组结构没办法直接用.点出来,要把数组进行处理,这里就用$unwind处理,下面是代码 1234567&#123;$unwind : '$service'&#125;,&#123;$group : &#123; _id : &#123;isHCS : '$target.isHCS' , serviceType : \"$service.category\"&#125;, price : &#123;$sum : '$price.value'&#125; &#125; &#125;]) $push 在$group的时候在集合里面放一个数组,只能push数组 123456789101112db.projectsms.aggregate([&#123;$unwind: '$phones'&#125;, &#123; $group: &#123; '_id': '$_id', 'name': &#123;$push : '$role'&#125;, 'state': &#123;$push : '$state'&#125;, 'projects': &#123;$push : '$projects._id'&#125;, 'phones': &#123;$push: '$phones'&#125; &#125; &#125;]) find语句 使用mongoose工具的时候可以使用一下方式进行过滤,不需要使用aggregate(聚合进行字段筛选): 123//params是筛选条件,&#123;name: 1, sex:1, identityNumber: 1&#125;意思是只要这些字段//默认_id字段也是返回的。如果需要去掉加上&#123;name: 1, sex:1, identityNumber: 1, _id: 0&#125;let content = await this.model.find(params,&#123;name: 1, sex:1, identityNumber: 1&#125;); updata语句1234await this.model.update( &#123;这里可以写条件和find的一样&#125; &#123;$set: &#123;'uuid': mongoose.Types.ObjectId().toString()&#125;&#125; );","categories":[{"name":"MongoDB整理","slug":"MongoDB整理","permalink":"http://yoursite.com/categories/MongoDB整理/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"}]},{"title":"VI的一些常用命令","slug":"VI的一些常用命令","date":"2018-06-05T08:21:12.000Z","updated":"2018-07-20T06:48:09.563Z","comments":true,"path":"VI的一些常用命令.html","link":"","permalink":"http://yoursite.com/VI的一些常用命令.html","excerpt":"VI的一些常用命令","text":"VI的一些常用命令 进入VI编辑 vi nginx.conf 输入 输入i键 跳到第一行 输入gg 删除一行 输入dd 删除所有 先输入gg到第一行,在按下d,在输入G 查找 输入 / 符号","categories":[{"name":"VI","slug":"VI","permalink":"http://yoursite.com/categories/VI/"}],"tags":[{"name":"VI","slug":"VI","permalink":"http://yoursite.com/tags/VI/"}]},{"title":"EGG 入门笔记","slug":"EGG 入门笔记","date":"2018-06-04T08:13:37.000Z","updated":"2018-07-19T07:06:17.079Z","comments":true,"path":"EGG 入门笔记.html","link":"","permalink":"http://yoursite.com/EGG 入门笔记.html","excerpt":"EGG框架快速上手","text":"EGG框架快速上手 0X00 这里基于我的情况,需要快速上手 0X01 基于Egg框架的项目启动 找到目录中的package.json,点击右键show npm scripts ,然后dev run,dev run是属于在测试环境中的模式,如果在win环境下跑run的话会出现好多窗口,是因为有多少启动了多个线程,就出现了那么多的窗口 0X02 Egg基本目录结构 controller文件夹和java的一样 extent 属于可选的,可以对框架进行扩展配置,详情见框架扩展 model 是属于Egg的自定义目录规范,详情Loader API public 属于可选,放置静态文件,详情egg-static service 和java的service层一样 router.js 这个主要是路由的配置,相当于servlet配置映射的路径,这个还是比较重要的 0X03 基于RESTful风格的简单的CURD0.Egg中规定的RESTful的请求 ctx的含义 ctx - 当前请求的 Context 实例。 Egg中规定的RESTful的请求 1.简述思路 这里举一个新闻的例子,对新闻进行CURD操作,从model层开始编写,在编写controller层,最后在配置路由router.js配置出RESTful风格的接口(这里不用编写service层是因为我controller继承了一个公共类,其中有最基础的CURD方法,所以说这次上手还是感觉比较简单) 2.Model层的编写,实体的写法 下面是一个新闻的实体 12345678910111213141516'use strict';module.exports = app =&gt; &#123; const mongoose = app.mongoose; const tempSchema = new mongoose.Schema(&#123; _id: mongoose.Schema.Types.ObjectId, tile: String, //标题 content: String, //内容 intro: String, //简介 creation: Number, //创建时间 updated: Number, //更新时间 &#125;, &#123; versionKey: false, &#125;); return mongoose.model('news', tempSchema);&#125;; use strict 表示使用严格模式为什么用严格模式 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 app.mongoose 调用mnogoDB插件 const tempSchema 表示mnogoDB的数据库类型?(暂时不确定,没有使用过mnogoDB) 5到10行就是字段 versionKey: false, 这个一个是个标准的写法吧 return mongoose.model(&#39;news&#39;, tempSchema); 这个可以对应到service层 3.编写Controller层 下面的新闻的controller 123456789101112131415161718192021222324252627282930313233343536373839'use strict';const CommonController = require('./commonController');class NewsController extends CommonController&#123; init() &#123; this.daoService = this.service.news; &#125; async create (ctx) &#123; await super.create(ctx); ctx.logger.debug(\"增加\"); &#125; async show (ctx) &#123; await super.show(ctx); ctx.logger.debug(\"根据ID展示\"); &#125; async index (ctx) &#123; await super.index(ctx); ctx.logger.debug(\"展示所有\"); &#125; async update (ctx) &#123; await super.update(ctx); ctx.logger.debug(\"更新\"); &#125; async destroy () &#123; await super.destroy(ctx); ctx.logger.debug(\"删除\"); &#125;&#125;module.exports = NewsController; 这里第一行也是使用严格模式,提高编译和运行速度 const CommonController = require(&#39;./commonController&#39;); 这是相当于java的导包操作,把commonController引用到当前类中(es6有class的写法) 第五行和java的class写法一样extends也一样表示继承 init() 表示初始化service层(感觉在egg框架还是es6的语法规则中,比如你要调用service层或者你要调用model层的实体的话,都是需要先进行init()进行初始化),虽然这里并没有用到新闻的service层 CRUD(那增加进行举例) 1234async create (ctx) &#123; await super.create(ctx); ctx.logger.debug(\"增加\"); &#125; async 表示使用异步的方式,await表示必须等到suoer.create的返回值在进行下一步在下面就是日志记录 4.简单介绍一下service层的写法 虽然简单的CURD我是基于现成的类进行编写的(在框架整合了简单的curd),但是在真实的业务情况中这些简单的CURD肯定是无法满足业务需求的,所以这里需要新的service层下面是例子 12345678910'use strict';const DaoService = require('./daoService');class NewsService extends DaoService&#123; init() &#123; this.model = this.ctx.model.News; &#125;&#125;module.exports = NewsService; 这里还是要先进行init()方法初始化 自定义的方法编写到daoService 中,这里进行引用应该就可以了 5.处理路由router.js 路由还是比较简单的,但是我觉得还是重要 下面是路由配置 123456789101112131415'use strict';const api = '/api/v1';/** * @param &#123;Egg.Application&#125; app - egg application */module.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; router.post(api + '/surveyRecords/search', controller.surveyRecords.index); router.get(api + '/surveyRecords/exportRecord', controller.surveyRecords.exportRecord); router.resources('surveyRecords', api + '/surveyRecords', controller.surveyRecords); // 角色 router.post(api + '/roles/search', controller.roles.index); router.resources('roles', api + '/roles', controller.roles); router.resources('news', api + '/news', controller.news);&#125;; 这里一样是使用严格模式 const api = &#39;/api/v1&#39; 规定请求路径 module.exports = app =&gt; {} 标准写法 const { router, controller } = app; 这个应该也是标准写法 router.post(api + &#39;/surveyRecords/search&#39;, controller.surveyRecords.index);这个是post请求到controller文件夹下的surveyRecords.js文件中的index方法 router.resources(&#39;news&#39;, api + &#39;/news&#39;, controller.news);这个是整合了post啊get啊那些的RESTful风格,可以根据你的请求进行自动访问规定的方法 0X04接口分析(居家养老服务管理系统)0.登录接口A. 路由 router.get(api + ‘/users/login’, controller.users.login); B. Controller层代码1234567891011121314151617181920async login(ctx) &#123; //从ctx 获取当前GET请求的参数。 const user = await this.service.users.login(ctx.query.phone, ctx.query.password); if (user &amp;&amp; user.roles) &#123; user.permissions = &#123;&#125;; const allPromise = Object.keys(user.roles).map(async s =&gt; &#123; if (Array.isArray(user.roles[s])) &#123; const roles = await this.getRolesBySystem(user.roles, s); user.permissions[s] = roles; &#125; else &#123; for (const orgId of Object.keys(user.roles[s])) &#123; const roles = await this.getRolesBySystemOrg(user.roles, s, orgId); user.permissions[s] = &#123;[orgId]: roles&#125;; &#125; &#125; &#125;); await Promise.all(allPromise); &#125; ctx.body = user;&#125; if (user &amp;&amp; user.roles)user不为空,user.roles不为空 Object.keys()返回一个数组 if (Array.isArray(user.roles[s]))判断是不是数组 getRolesBySystem() C. Service层代码中的login()方法12345678async login(phone, password) &#123; const md5Pass = this.ctx.helper.md5(password); const queries = &#123; $or: [&#123;phone&#125;, &#123;shortName: phone&#125;], password: md5Pass, &#125;; return await this.model.findOne(queries).lean();&#125; 1.通过controller层的const user = await this.service.users.login(ctx.query.phone, ctx.query.password);调用到service层来 2.const md5Pass = this.ctx.helper.md5(password);调用help层(相当于java的util)进行MD5处理 3.$or是个重点,这里举一个官方例子: 1db.inventory.find( &#123; $or: [ &#123; quantity: &#123; $lt: 20 &#125; &#125;, &#123; price: 10 &#125; ] &#125; ) 意思是取出inventory(存货) 集合,条件在$or中分别有两个条件,第一个是quantity字段的值小于20或者price字段等于10,$lt的意思就是小于某个值(以后会有更详细的文章来介绍MongoDB的语法) 4.$or: [{phone}, {shortName: phone}], password: md5Pass先来大概分析这句的意思,肯定有两个条件$or中是一个条件,逗号后面是一个条件。在来分析$or中的条件,$or肯定是有两个条件,系统可以用两种账号来进行登录,第一个种是手机也就是phone字段,第二种是短命登录也就是shortName字段,{phone}相当于{phone:phone},我猜测用{phone}简写是因为在数据库的字段和这里的字段是一样的。第一个条件就分析完了，在来分析第二个条件也就是password: md5Pass这个没有$or说明这个值是一个必须满足的条件。最后在梳理一下，假如传入参数为phone=110,password=123，那么这条语句的意思是在数据库中查找phone字段等于110，或者shortName字段等于110，同时满足password字段=123 5.return await this.model.findOne(queries).lean();model层的实体都有一些默认的方法，findOne()就是其中一个，这里传入的参数就是上面拼接的MongoDB数据库语句 6.lean()这里单独说一下lean()，不加这个方法的话他返回的对象中就带有model的一些默认方法,所以要加这个方法 getRolesBySystem()方法123456async getRolesBySystem(userRoles, system) &#123; const searchParams = &#123;system, name: &#123;$in: userRoles[system]&#125;&#125;; const roles = await this.service.roles.find(searchParams); const results = roles.map(a =&gt; (&#123;[a.name]: a.permission&#125;)).reduce((a, b) =&gt; (&#123;...a, ...b&#125;), &#123;&#125;); return results;&#125; 接收到传入的userRoles数组 和system(相当于Key)","categories":[{"name":"EGG","slug":"EGG","permalink":"http://yoursite.com/categories/EGG/"}],"tags":[{"name":"EGG","slug":"EGG","permalink":"http://yoursite.com/tags/EGG/"}]},{"title":"Jeecg在后台进行更新内容的时候报错","slug":"Jeecg在后台进行更新内容的时候报错","date":"2018-06-04T07:33:27.000Z","updated":"2018-07-20T02:41:41.409Z","comments":true,"path":"Jeecg在后台进行更新内容的时候报错.html","link":"","permalink":"http://yoursite.com/Jeecg在后台进行更新内容的时候报错.html","excerpt":"部署到Linux服务器在后台进行更新案例内容的时候出现下面这个错误","text":"部署到Linux服务器在后台进行更新案例内容的时候出现下面这个错误 0.环境 本机是win10,问题出现在部署到Linux服务器在后台进行更新案例内容的时候出现下面这个错误: 1.解决 百度了一下这个问题说的好像是在3.6的jeecg版本中出现过,个人感觉是windows和Linux时间格式化的问题,具体的解决方式在下面的目录中: 在这个两个bean中 12&lt;bean id=\"freemarker\" class=\"freemarker.template.Configuration\"&gt;&lt;bean id=\"freemarkerWord\" class=\"freemarker.template.Configuration\"&gt; 继续添加 1234&lt;property name=\"numberFormat\" value=\"0\"&gt;&lt;/property&gt;&lt;property name=\"dateFormat\" value=\"yyyy-MM-dd\"&gt;&lt;/property&gt;&lt;property name=\"timeFormat\" value=\"HH:mm:ss\"&gt;&lt;/property&gt;&lt;property name=\"dateTimeFormat\" value=\"yyyy-MM-dd HH:mm:ss\"&gt;&lt;/property&gt; 举一个添加完成的例子 12345678&lt;bean id=\"freemarkerWord\" class=\"freemarker.template.Configuration\"&gt; &lt;property name=\"templateLoader\" ref=\"templetLoaderWord\" /&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\"&gt;&lt;/property&gt; &lt;property name=\"numberFormat\" value=\"0\"&gt;&lt;/property&gt; &lt;property name=\"dateFormat\" value=\"yyyy-MM-dd\"&gt;&lt;/property&gt; &lt;property name=\"timeFormat\" value=\"HH:mm:ss\"&gt;&lt;/property&gt; &lt;property name=\"dateTimeFormat\" value=\"yyyy-MM-dd HH:mm:ss\"&gt;&lt;/property&gt;&lt;/bean&gt; 2.疑问 貌似这样操作过后,以后比如我新增一个案例,或者新闻的时候,creatTime这个字段会录不进去","categories":[{"name":"Jeecg","slug":"Jeecg","permalink":"http://yoursite.com/categories/Jeecg/"}],"tags":[{"name":"Jeecg","slug":"Jeecg","permalink":"http://yoursite.com/tags/Jeecg/"}]},{"title":"Tomcat实时日志查看","slug":"Tomcat实时日志查看","date":"2018-05-31T01:45:19.000Z","updated":"2018-07-20T06:45:42.573Z","comments":true,"path":"Tomcat实时日志查看.html","link":"","permalink":"http://yoursite.com/Tomcat实时日志查看.html","excerpt":"Tomcat实时日志查看","text":"Tomcat实时日志查看 进入logs日目录 tail -f catalina.out -n 可以指定展示多少行 例如 tail -n 5 catalina.out 这里展示5行","categories":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/categories/Tomcat/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"}]},{"title":"端口被使用","slug":"端口被使用","date":"2018-05-30T09:04:42.000Z","updated":"2018-07-20T03:34:06.700Z","comments":true,"path":"端口被使用.html","link":"","permalink":"http://yoursite.com/端口被使用.html","excerpt":"Linux端口被使用","text":"Linux端口被使用 netstat -anp 显示系统端口使用情况 netstat -anp|grep 40001 查看使用8080端口的程序 sudo netstat -tunlp|grep 3308 kill -9 进程PID","categories":[{"name":"端口占用","slug":"端口占用","permalink":"http://yoursite.com/categories/端口占用/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"IDEA处理非SpringBoot的启动方法","slug":"IDEA处理非SpringBoot的启动方法","date":"2018-05-18T03:09:29.000Z","updated":"2018-07-18T10:09:28.041Z","comments":true,"path":"IDEA处理非SpringBoot的启动方法.html","link":"","permalink":"http://yoursite.com/IDEA处理非SpringBoot的启动方法.html","excerpt":"记录下配置非SpringBoot的问题","text":"记录下配置非SpringBoot的问题 1. 2. 3. 4.启动在试试启动","categories":[{"name":"IDEA","slug":"IDEA","permalink":"http://yoursite.com/categories/IDEA/"}],"tags":[{"name":"IDEA,","slug":"IDEA","permalink":"http://yoursite.com/tags/IDEA/"},{"name":"疑难杂症","slug":"疑难杂症","permalink":"http://yoursite.com/tags/疑难杂症/"}]},{"title":"HEXO博客搭建的坑","slug":"HEXO博客搭建的坑","date":"2018-05-18T02:37:28.000Z","updated":"2018-07-18T09:51:46.099Z","comments":true,"path":"HEXO博客搭建的坑.html","link":"","permalink":"http://yoursite.com/HEXO博客搭建的坑.html","excerpt":"记录下第二次搭建博客的流程","text":"记录下第二次搭建博客的流程 前景 原来的博客换了电脑就没法更新了,很麻烦,这里我使用分支的方式进行部署,顺便记录一下自己遇到问题 0X00 环境配置 配置nodejs 安装git命令客户端 配置git,命令为 git config --global user.name &quot;你的github名字&quot; , git config --global user.email &quot;你的github邮箱&quot; 0X01 GitHub仓库创建 第一步 第二步 注意这里名字要用自己的GitHub用户名加.github.io,才能让GitHub自动给你分配githubpage 第三步 在仓库里面随便创建一个REMDME文件,方便修改分支 第四步 新建一个分支 设置为默认分支 0X02 配置HEXO 第一步 使用git把你的默认分支clone下来(直接复制地址clone肯定是你的默认分支) 第二步 进入项目目录在git用使用hexo init blog 把blog文件中的东西复制到你的项目目录去(如果blog文件中有.git的话就删除在复制就完了) 第三步 使用github的windows客户端把修改提交到分支 0X03 部署 ‘hexo g’ hexo s //启动本地服务,方便看效果 hexo d //提交到分支了,然后master分支就合并了 上一步可能存在一些问题,我平常更新是结合github的Windows客户端进行提交,也就是我hexo s启动过后看效果,ok的话我就直接用客户端进行上传,上传完成过后访问线上网站并不会更新,我需要点击 这个按钮才会更新线上的(原因我没研究,怪我github用的太少) 0X04 遇到的问题 ERROR Plugin load failed: hexo-server解决: sudo npm install hexo-server hexo-renderer相关的错误解决: npm install hexo-renderer-ejs --save npm install hexo-renderer-stylus --save npm install hexo-renderer-marked --save 这个时候再重新生成静态文件，命令： hexo generate （或hexo g） 启动本地服务器： hexo server （或hexo s）","categories":[{"name":"HEXO","slug":"HEXO","permalink":"http://yoursite.com/categories/HEXO/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"http://yoursite.com/tags/HEXO/"}]},{"title":"Spring 的Context 上下文简单例子","slug":"Spring 的Context 上下文简单例子","date":"2018-05-18T02:37:28.000Z","updated":"2018-07-20T07:09:42.701Z","comments":true,"path":"Spring 的Context 上下文简单例子.html","link":"","permalink":"http://yoursite.com/Spring 的Context 上下文简单例子.html","excerpt":"Spring 的Context 上下文简单例子(技术不够啊,现在还没理解)","text":"Spring 的Context 上下文简单例子(技术不够啊,现在还没理解) 前言简单例子便于以后使用,这里Man注入是采用构造器注入,需要QQcar类,所以在XML配置的时候使用的constructor-arg,来指定构造器需要的东西 1.基于xml的配置方式12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\"&gt; &lt;bean id=\"man\" class=\"spring.chapter1.domain.Man\"&gt; &lt;constructor-arg ref=\"qqCar\" /&gt; &lt;/bean&gt; &lt;bean id=\"qqCar\" class=\"spring.chapter1.domain.QQCar\"/&gt;&lt;/beans&gt; 配置完成后 1234567891011public class Test &#123; public static void main(String[] args) &#123; //加载项目中的spring配置文件到容器// ApplicationContext context = new ClassPathXmlApplicationContext(\"resouces/applicationContext.xml\"); //加载系统盘中的配置文件到容器(两种方式都能获取) ApplicationContext context = new FileSystemXmlApplicationContext(\"E:/Spring/applicationContext.xml\"); //从容器中获取对象实例 Man man = context.getBean(Man.class); man.driveCar(); &#125;&#125; 基于注解式123456789101112//同xml一样描述bean以及bean之间的依赖关系@Configurationpublic class ManConfig &#123; @Bean public Man man() &#123; return new Man(car()); &#125; @Bean public Car car() &#123; return new QQCar(); &#125;&#125; 配置完成 123456789public class Test &#123; public static void main(String[] args) &#123; //从java注解的配置中加载配置到容器 ApplicationContext context = new AnnotationConfigApplicationContext(ManConfig.class); //从容器中获取对象实例 Man man = context.getBean(Man.class); man.driveCar(); &#125;&#125;","categories":[{"name":"ApplicationContext","slug":"ApplicationContext","permalink":"http://yoursite.com/categories/ApplicationContext/"}],"tags":[{"name":"spring,","slug":"spring","permalink":"http://yoursite.com/tags/spring/"},{"name":"Context上下文","slug":"Context上下文","permalink":"http://yoursite.com/tags/Context上下文/"}]},{"title":"我的IDEA常用插件","slug":"我的IDEA常用插件","date":"2018-02-28T01:45:00.000Z","updated":"2018-07-18T10:13:21.320Z","comments":true,"path":"我的IDEA常用插件.html","link":"","permalink":"http://yoursite.com/我的IDEA常用插件.html","excerpt":"记录下使用IDEA开发下常用的插件","text":"记录下使用IDEA开发下常用的插件 CodeGlance 代码预览 Alibaba Java Coding Guidelines 代码审查,根据阿里巴巴Java开发守则 grep-console 日志颜色区分,结合log4j activate-power-mode 写代码时的动画效果 Maven Helper 一旦安装了Maven Helper插件，只要打开pom文件，就可以打开该pom文件的Dependency Analyzer视图（在文件打开之后，文件下面会多出这样一个tab），进入Dependency Analyzer视图之后有三个查看选项，分别是Conflicts(冲突)、All Dependencies as List(列表形式查看所有依赖)、All Dependencies as Tree(树结构查看所有依赖)。并且这个页面还支持搜索。很方便！并且使用该插件还能快速的执行maven命令。 FindBugs 查找BUG Jrebel 热部署插件 类注释模板 File and Code Templates 中设置class 添加模板 12345678910/*** @program: $&#123;PROJECT_NAME&#125;** @description: $&#123;description&#125;** @author: lq** @create: $&#123;YEAR&#125;/$&#123;MONTH&#125;/$&#123;DAY&#125;**/","categories":[{"name":"IDEA","slug":"IDEA","permalink":"http://yoursite.com/categories/IDEA/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://yoursite.com/tags/IDEA/"}]},{"title":"LinkedList,学习总结","slug":"LinkedList,学习总结","date":"2018-01-22T02:46:07.000Z","updated":"2018-07-20T02:46:25.243Z","comments":true,"path":"LinkedList,学习总结.html","link":"","permalink":"http://yoursite.com/LinkedList,学习总结.html","excerpt":"学习链表结构的记录而已","text":"学习链表结构的记录而已 前言 队列、堆栈与数组、链表的关系与区分 1.先要搞明白两个东西,数据结构,和数据存储结构 数据结构：是指相互之间存在一种或多种特定关系的数据元素的 集合。听起来是不是很抽象，简单理解：数据结构就是描述对象间逻辑关系的学科。比如：队列就是一种先进先出的逻辑结构，栈是一种先进后出的逻辑结构，家谱 是一种树形的逻辑结构！（初学数据结构的时候很不理解为什么有“栈”这个东西；队列很容易理解—无论购物就餐都需要排队；栈可以认为就是个栈道— 只允许一个人通过的小道，而且只能从一端进入，然后再从这端返回，比如你推了个箱子进去啦，第二个人也推个箱子进去，此时只能等后进来的这个人拉着箱子出 去后，你才能退出。） 数据存储结构：它是计算机的一个概念，简单讲，就是描述数据在计算机中存储方式的学科；常用的数据存储 方式就两种：顺序存储，非顺序存储！顺序存储就是把数据存储在一块连续的存储介质（比如硬盘或内存）上—-举个例子：从内存中拿出第100个字节到 1000个字节间的连续位置，存储数据；数组就是典型的顺序存储！非顺序存储就是各个数据不一定存在一个连续的位置上，只要每个数据知道它前面的数据和后 面的数据，就能把所有数据连续起来啦；链表就是典型的非顺序存储啦！ 队列、栈是线性数据结构的典型代表，而数组、链表是常用的两种数据存储结构；队列和栈均可以用数组或链表的存储方式实现它的功能！ 双向链表 LinkedList它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。这种叫做双向链表也叫双链表 LinkedList LinkedList中定义了3个属性first,last,size,如下: 123456789101112131415transient int size = 0;/** * Pointer to first node. * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) */transient Node&lt;E&gt; first;/** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */transient Node&lt;E&gt; last; first表示上一个节点的信息 last表示下一个节点的信息 size表示双向链表中节点实例的个数 节点 LinkedList是采用节点Node方式把前后两个节点关联起来,变成链表,在LinkedList的源码中有个节点的内部类 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; LinkedList之所以是双向链表就是因为Node节点中的next和prev两个参数把链串联起来 next:保存下一个节点的信息 prev:保存上一个节点的信息 element:节点的具体内容(相当于业务数据) LinkedList中的remove()方法分析1234567/*** 返回泛型*/public E remove() &#123; //调用removeFirst方法 return removeFirst();&#125; removeFirst() 123456789101112131415/** * 删除并返回此列表中的第一个元素。 * * @return 列表中的第一个元素。 * @throws 如果这个列表是空的，则抛出NoSuchElementException。 */public E removeFirst() &#123; //把第一个元素拿出来 final Node&lt;E&gt; f = first; //如果为空就报异常 if (f == null) throw new NoSuchElementException(); //进入unlinkFirst(f) return unlinkFirst(f);&#125; unlinkFirst(f) 1234567891011121314151617181920212223242526272829/** * 取消链接非空的第一个节点f。 */private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; //从需要移除的元素中把业务数据拿出来 final E element = f.item; //从需要移除的元素中把下一个节点的信息拿出来 //现在next节点就变成了 final Node&lt;E&gt; next = f.next; //把需要移除的节点的数据设为空 f.item = null; //把需要移除的元素的下一个节点设置为空,利用GC回收 f.next = null; // help GC //然后把这个链表的第一个设置为next节点 first = next; //判断f节点的下一个节点是否为空,为空的话,这个链表的下个节点也就为空,整个双向链表就为空了 if (next == null) last = null; else //不为空的话,现在next节点就变成了,整个双向链表的第一个节点,所以next节点的上一个节点就为空了 next.prev = null; //双向链表的长度减少 size--; //次数这个是??暂时没弄明白 modCount++; //返回f节点的业务数据 return element; &#125; LinkedList中的add(E e)方法分析1234567891011/** *将指定的元素追加到列表的末尾。 *该方法相当于#addLast。 * @param e 要添加到此列表中的元素。 * @return true */public boolean add(E e) &#123; //调用linkLast(e)方法 linkLast(e); return true;&#125; linkLast(e) 12345678910111213141516171819/** * 链接e作为最后一个元素。 */void linkLast(E e) &#123; //让last最后一个节点赋值给l final Node&lt;E&gt; l = last; //调用内部类Node节点的构造方法 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //让最后一个节点last的值变为newNode last = newNode; //如果最后一个节点为空,就让newNode变成第一个节点first if (l == null) first = newNode; else //不为空的话,让最后一个节点的下一个节点设置为newNode l.next = newNode; size++; modCount++;&#125; 内部类class Node&lt;E&gt;: 12345678910111213private static class Node&lt;E&gt; &#123; E item; //节点业务数据信息,使用泛型 Node&lt;E&gt; next; //当前节点的下一个节点信息 Node&lt;E&gt; prev; //当前节点的上一个节点信息 //在new一个Node时,比如add(e) 方法是保存到双向链表的尾部,肯定需要上一个节点的信息 //参数信息prev:上一个节点;element:当前new的节点所需要的业务数据;next:下一个节点的信息 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; //1.把需要的业务数据,添加到节点中的item中 this.next = next; //2.填写下一个节点信息,可以为null,比如在add()方法中就体现了 this.prev = prev; //3.因为这是一个新的节点所以需要指定上一个节点 &#125;&#125; LinkedList中的get(int index)方法分析12345678910111213/** * 返回列表中指定位置的元素。 * * @param index 返回元素的索引。 * @return the 元素在列表中的指定位置。 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; //第一步调用checkElementIndex(index)方法检查下标是否越界 checkElementIndex(index); //第二步,调用node(index)方法 return node(index).item;&#125; 第一步检查下标越界情况 checkElementIndex(index)方法,其中有个构造异常信息的方法 1234567891011121314/** * Constructs an IndexOutOfBoundsException detail message. * Of the many possible refactorings of the error handling code, * this \"outlining\" performs best with both server and client VMs. */private String outOfBoundsMsg(int index) &#123; return \"Index: \"+index+\", Size: \"+size;&#125;private void checkElementIndex(int index) &#123; //这里调用了isElementIndex(index)方法,判断下标是否越界,越界抛出异常 if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; - `isElementIndex(index)`方法 1234567/** * 说明参数是否为现有元素的索引。 */private boolean isElementIndex(int index) &#123; //判断是否下标越界,返回true或者false return index &gt;= 0 &amp;&amp; index &lt; size;&#125; 第二步,确定元素位置 node(index)方法 123456789101112131415161718192021/*** 返回指定元素索引中的(非空)节点。*/Node&lt;E&gt; node(int index) &#123;// assert isElementIndex(index);//这里使用的是二分查找法,如果size右移1位,代表size的一半大小;这种情况下如果,元素的下标index小于的元素的一半说明,元素的位置在前半截,所以从firsy开始遍历if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; //这里遍历到指定元素的前一位停止,然后取出前一位的下一位,得到指定元素,节约性能 for (int i = 0; i &lt; index; i++) x = x.next; return x;&#125; else &#123; Node&lt;E&gt; x = last; //这里同理,从最后一个开始遍历,遍历的下标i-1,如果i大于了,指定元素的下标说明,i这个节点的前一个就是指定的元素,所以用x.prev,就可以了 for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; LinkedList中的set(int index, E element)方法分析1234567891011121314151617181920/** * 将元素替换为该列表中指定位置的元素。 * * @param 要替换的元素的索引索引。 * @param 要存储在指定的位置和元素。 * @return 在指定位置之前的元素的业务数据。 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E set(int index, E element) &#123; //调用检查下标是否越界的方法,和get(Int index)方法一样 checkElementIndex(index); //取出指定下标位置的节点node(index)方法和上面一样 Node&lt;E&gt; x = node(index); //把节点x的老数据取出来 E oldVal = x.item; //把新数据给x节点 x.item = element; //返回x节点的老数据 return oldVal;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"LinkedList","slug":"LinkedList","permalink":"http://yoursite.com/tags/LinkedList/"}]},{"title":"HashMap的负载因子","slug":"HashMap的负载因子","date":"2018-01-22T01:56:00.000Z","updated":"2018-07-18T09:59:16.498Z","comments":true,"path":"HashMap的负载因子.html","link":"","permalink":"http://yoursite.com/HashMap的负载因子.html","excerpt":"学习数据结构的笔记","text":"学习数据结构的笔记 在使用LinkedHashMap时,如下: 12345public class test &#123; public static void main(String[] args) &#123; Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;(); &#125;&#125; 发现LinkedHashMap中的构造方法 1234public LinkedHashMap() &#123; super(); accessOrder = false; &#125; 发现调用的父类HashMap其中的一个构造方法 123public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; 其中的DEFAULT_LOAD_FACTOR常量被设定为0.75,如下 1static final float DEFAULT_LOAD_FACTOR = 0.75f; 这就是HashMap负载因子的默认值 而HashMap的另一个构造函数: 123456789101112131415161718192021/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; 其中有两个参数initialCapacity和loadFactor initialCapacity表示map的初始化容量，initialCapacity &gt; MAXIMUM_CAPACITY，表明map的最大容量是1&lt;&lt;30,也就是1左移30位，每左移一位乘以2，所以就是1*2^30=1073741824 loadFactor是map的负载因子,loadFactor &lt;= 0 || Float.isNaN(loadFactor),表明负载因子要大于0，且是非无穷大的数字 负载因子为什么会影响HashMap的性能? 这里借用sxlzs_博主的解释 我们都知道有序数组存储数据，对数据的索引效率都很高，但是插入和删除就会有性能瓶颈（回忆ArrayList）， 链表存储数据，要一次比较元素来检索出数据，所以索引效率低，但是插入和删除效率高（回忆LinkedList）， 两者取长补短就产生了哈希散列这种存储方式，也就是HashMap的存储逻辑. 而负载因子表示一个散列表的空间的使用程度，有这样一个公式：initailCapacity*loadFactor=HashMap的容量。 所以负载因子越大则散列表的装填程度越高，也就是能容纳更多的元素，元素多了，链表大了，所以此时索引效率就会降低。 反之，负载因子越小则链表中的数据量就越稀疏，此时会对空间造成烂费，但是此时索引效率高。 如何科学的设置initailCapacity,loadFactor的值: HashMap有三个构造函数，可以选用无参构造函数，不进行设置。默认值分别是16和0.75 官方的建议是initailCapacity设置成2的n次幂，laodFactor根据业务需求，如果迭代性能不是很重要，可以设置大一下。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"HashMap","slug":"HashMap","permalink":"http://yoursite.com/tags/HashMap/"}]},{"title":"JavaFx苦逼之路","slug":"JavaFx爬坑之旅","date":"2018-01-12T01:42:00.000Z","updated":"2018-07-18T10:15:40.156Z","comments":true,"path":"JavaFx爬坑之旅.html","link":"","permalink":"http://yoursite.com/JavaFx爬坑之旅.html","excerpt":"啊啊啊,JavaFX贼难玩,不喜欢","text":"啊啊啊,JavaFX贼难玩,不喜欢 前言目前我能用javafx做的东西都很少,还跟在大佬屁股后面学习.说不定写着写着就脱坑停更! 绑定tableView 需求是绑定几个测试参数到tableView下如图 结构为:tabPane -&gt; Tab -&gt; tableView -&gt; 若干个TableColumn 第一步先设置fx:idtableView上肯定需要fx:id,然后在给每一列绑定fx:id,如下图 第二步,编写相关联的实体由于我的tableview中显示的数据封装在了实体类中,所以这里我们需要先定义实体,实体的定义如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137import javafx.beans.property.DoubleProperty;import javafx.beans.property.IntegerProperty;import javafx.beans.property.SimpleDoubleProperty;import javafx.beans.property.StringProperty;/** * 限价委托实体类 */public class LimitEntrustEntity extends Commission&#123; private DoubleProperty orderState = new SimpleDoubleProperty(); //已成交数量 private DoubleProperty priceOfOrder = new SimpleDoubleProperty(); //成交均价 private DoubleProperty gvm = new SimpleDoubleProperty(); //成交总额 public LimitEntrustEntity(DoubleProperty orderState, DoubleProperty priceOfOrder, DoubleProperty gvm) &#123; this.orderState = orderState; this.priceOfOrder = priceOfOrder; this.gvm = gvm; &#125; public LimitEntrustEntity() &#123; &#125; public double getOrderState() &#123; return orderState.get(); &#125; public DoubleProperty orderStateProperty() &#123; return orderState; &#125; public void setOrderState(double orderState) &#123; this.orderState.set(orderState); &#125; public double getPriceOfOrder() &#123; return priceOfOrder.get(); &#125; public DoubleProperty priceOfOrderProperty() &#123; return priceOfOrder; &#125; public void setPriceOfOrder(double priceOfOrder) &#123; this.priceOfOrder.set(priceOfOrder); &#125; public double getGvm() &#123; return gvm.get(); &#125; public DoubleProperty gvmProperty() &#123; return gvm; &#125; public void setGvm(double gvm) &#123; this.gvm.set(gvm); &#125; @Override public double getCommissionQty() &#123; return super.getCommissionQty(); &#125; @Override public DoubleProperty commissionQtyProperty() &#123; return super.commissionQtyProperty(); &#125; @Override public void setCommissionQty(double commissionQty) &#123; super.setCommissionQty(commissionQty); &#125; @Override public double getCommissionTime() &#123; return super.getCommissionTime(); &#125; @Override public DoubleProperty commissionTimeProperty() &#123; return super.commissionTimeProperty(); &#125; @Override public void setCommissionTime(double commissionTime) &#123; super.setCommissionTime(commissionTime); &#125; @Override public double getCommissionPrice() &#123; return super.getCommissionPrice(); &#125; @Override public DoubleProperty commissionPriceProperty() &#123; return super.commissionPriceProperty(); &#125; @Override public void setCommissionPrice(double commissionPrice) &#123; super.setCommissionPrice(commissionPrice); &#125; @Override public int getState() &#123; return super.getState(); &#125; @Override public IntegerProperty stateProperty() &#123; return super.stateProperty(); &#125; @Override public void setState(int state) &#123; super.setState(state); &#125; @Override public String getOrderSource() &#123; return super.getOrderSource(); &#125; @Override public StringProperty orderSourceProperty() &#123; return super.orderSourceProperty(); &#125; @Override public void setOrderSource(String orderSource) &#123; super.setOrderSource(orderSource); &#125;&#125; 这里我继承了父类,父类如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.yczr.threebody.pc.entity;import javafx.beans.property.*;import java.io.Serializable;public class Commission implements Serializable &#123; private DoubleProperty commissionQty = new SimpleDoubleProperty(); //委托数量 2 private DoubleProperty commissionTime = new SimpleDoubleProperty(); //委托时间 2// private DoubleProperty triggerPrice; //触发价格 1 private DoubleProperty commissionPrice = new SimpleDoubleProperty(); //委托价格 2// private TradeStatus realTriggerPrice; //真实触发价 1 private IntegerProperty state = new SimpleIntegerProperty(); //状态 2 private StringProperty orderSource = new SimpleStringProperty(); //订单来源 2 public double getCommissionQty() &#123; return commissionQty.get(); &#125; public DoubleProperty commissionQtyProperty() &#123; return commissionQty; &#125; public void setCommissionQty(double commissionQty) &#123; this.commissionQty.set(commissionQty); &#125; public double getCommissionTime() &#123; return commissionTime.get(); &#125; public DoubleProperty commissionTimeProperty() &#123; return commissionTime; &#125; public void setCommissionTime(double commissionTime) &#123; this.commissionTime.set(commissionTime); &#125;// public double getTriggerPrice() &#123;// return triggerPrice.get();// &#125;//// public DoubleProperty triggerPriceProperty() &#123;// return triggerPrice;// &#125;//// public void setTriggerPrice(double triggerPrice) &#123;// this.triggerPrice.set(triggerPrice);// &#125; public double getCommissionPrice() &#123; return commissionPrice.get(); &#125; public DoubleProperty commissionPriceProperty() &#123; return commissionPrice; &#125; public void setCommissionPrice(double commissionPrice) &#123; this.commissionPrice.set(commissionPrice); &#125; public int getState() &#123; return state.get(); &#125; public IntegerProperty stateProperty() &#123; return state; &#125; public void setState(int state) &#123; this.state.set(state); &#125; public String getOrderSource() &#123; return orderSource.get(); &#125; public StringProperty orderSourceProperty() &#123; return orderSource; &#125; public void setOrderSource(String orderSource) &#123; this.orderSource.set(orderSource); &#125;&#125; 顺便说一下这里遇到的坑!!!!! 定义需要绑定的值时,属性还是用的以前的类型,比如Double类型还是用的Double,但是在javafx中Double变为了javafx中的封装类型DoubleProperty,其它的数据类型应该也是这样; 实体类我用的随机数进行赋值,代码如下: 1234567891011121314151617181920212223public static Double getRandom(int max)&#123; double v = new Random(max).nextDouble(); return v; &#125; public static Double getRandom()&#123; Double random = getRandom(1000); return random; &#125; public static LimitEntrustEntity getLeEntity() &#123; LimitEntrustEntity leEntity = new LimitEntrustEntity(); leEntity.setCommissionPrice(getRandom()); leEntity.setCommissionQty(getRandom()); leEntity.setCommissionTime(getRandom()); leEntity.setGvm(getRandom()); leEntity.setOrderSource(getRandom().toString()); leEntity.setOrderState(getRandom()); leEntity.setPriceOfOrder(getRandom()); leEntity.setState(getRandom().intValue()); return leEntity; &#125; 其中的坑是真的多!,我没有没父类Commission中的属性设置默认值,导致加载数据时为空 第三步,在代码中与fx:id绑定虽然在fxml文件中设置了fx:id,但是在实际的程序中并没有做任何相关联的绑定,所以这一步就需要进行相关的绑定; 定义数据源 1private ObservableList&lt;TradeOverviewEntity&gt; exchangeData = FXCollections.observableArrayList(); 绑定TableView 12@FXMLprivate TableView&lt;TradeOverviewEntity&gt; exTable; 绑定列TableColumn 12345678@FXMLprivate TableColumn&lt;TradeOverviewEntity, String&gt; coinName;@FXMLprivate TableColumn&lt;TradeOverviewEntity, Number&gt; exPrice;@FXMLprivate TableColumn&lt;TradeOverviewEntity, Number&gt; exMaxPrice; //..........省略其它列 加载数据 前面虽然绑定了数据源,但是并没有进行实际的赋值,下面先把值和列对应上 12345678910 private void initBean()&#123; lpwtTime.setCellValueFactory(cellData -&gt; cellData.getValue().commissionTimeProperty()); //委托时间 plNumber.setCellValueFactory(cellData -&gt; cellData.getValue().commissionQtyProperty()); //委托数量 plDeal.setCellValueFactory(cellData -&gt; cellData.getValue().orderStateProperty()); //已成交 plPrice.setCellValueFactory(cellData -&gt; cellData.getValue().commissionPriceProperty()); //委托价格 plPrice2.setCellValueFactory(cellData -&gt; cellData.getValue().priceOfOrderProperty()); //成交均价(QC) plTotal.setCellValueFactory(cellData -&gt; cellData.getValue().commissionTimeProperty()); //成交总额(QC) plState.setCellValueFactory(cellData -&gt; cellData.getValue().stateProperty()); //状态 plSource.setCellValueFactory(cellData -&gt; cellData.getValue().orderSourceProperty()); //状态&#125; 对数据进行赋值 123456private void loadData()&#123; //随机生成5个订单 for (int i = 0; i &lt; 5; i++) &#123; limitEntrusData.add(BeanUtils.getLeEntity()); &#125; &#125; 初始化加载数据 1234567@FXMLprivate void initialize() &#123; initBean(); loadData(); lpTable.setItems(limitEntrusData);&#125; 效果 监听TextField变化目的是为了完成界面简单的密码强度判断,如下界面 绑定fxid 其它的fxid就不一一绑定了 编写监听方法123456789101112131415161718192021public void testyy() &#123; password.textProperty().addListener(new ChangeListener&lt;String&gt;() &#123; @Override public void changed(ObservableValue&lt;? extends String&gt; observable, String oldValue, String newValue) &#123; //下面是逻辑处理部分 if (password.getText().equals(\"\") || password.getText().length() &lt; 1) &#123; pwIntensity.setText(\"登录密码不能为空\"); &#125; else &#123; String intensity = null; if (password.getText().length() &gt; 5) &#123; intensity = \"强\"; &#125; else if (password.getText().length() &lt; 5) &#123; intensity = \"弱\"; &#125; else &#123; intensity = \"极强\"; &#125; pwIntensity.setText(\"密码强度\" + intensity); &#125; &#125; &#125;);&#125; 调用监听监听需要在页面初始化的时候就进行加载,所以在initialize()中吊起 1234@FXMLprivate void initialize() &#123; testyy();&#125; 效果","categories":[{"name":"JavaFx","slug":"JavaFx","permalink":"http://yoursite.com/categories/JavaFx/"}],"tags":[{"name":"JavaFx","slug":"JavaFx","permalink":"http://yoursite.com/tags/JavaFx/"}]},{"title":"Spring Cloud初体验","slug":"Spring Cloud初体验","date":"2017-12-25T07:08:21.000Z","updated":"2018-07-20T06:42:58.213Z","comments":true,"path":"Spring Cloud初体验.html","link":"","permalink":"http://yoursite.com/Spring Cloud初体验.html","excerpt":"上周星期五的时候,完成了一次springcloud的小体验,现在把流程和想法记下来","text":"上周星期五的时候,完成了一次springcloud的小体验,现在把流程和想法记下来 前言 按照网上的教程来写的demo 首先需要一个服务端,还需要一个服务提供者,而且服务提供者需要把自己注册到服务端,另外还需要一个服务消费者,服务提供者也可以是服务消费者 熔断器Hystrix的话,就相当于短路机制.熔断器在什么情况先需要呢?我的理解是,比如在A调用B的服务表明上是直接调用的B,其实是A请求服务端,服务端在把B服务提供给A,如果发生A调用B,B在调用C,这个过程就是A请求服务端发送给了B,B在请求服务端,服务端在把C服务给B,B在给A;这种情况下如果C服务出现问题,或者延迟的话,B就会一直等待C的响应,然后A就会一直等待B的响应,要不到多久这种连锁反应就会让集群崩溃在这种情况下熔断器的作用就体现出来了熔断器会在,请求服务,服务出现多次错误或者延迟的情况下把出现错误或者延迟的服务关闭掉,让请求这个服务的其它程序回调(fallback),这样就不会出现集群的连锁反应 建立服务端 在最基本的springboot项目的pom.xml文件里面加入如下依赖: 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Brixton.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 注意添加依赖的方式 修改配置文件 12345678910server: port: 1111eureka: client: # 这里把服务端注册自己到服务里改为false register-with-eureka: false fetch-registry: false serviceUrl: defaultZone: //localhost:$&#123;server.port&#125;/eureka/ 修改启动类 12345678@EnableEurekaServer@SpringBootApplicationpublic class SpringCloudDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringCloudDemoApplication.class, args); &#125;&#125; 加入 @EnableEurekaServer 启动效果如下(我启动了两个服务提供方,设定了不同的端口,一个有say方法,一个没有): 创建服务提供者 在基本的springboot项目上添加依赖 123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Brixton.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 修改配置 12345spring.application.name=compute-serviceserver.port=2222eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ 编写服务controller 123456789101112131415161718192021222324/** * 创建时间:2017/12/22 0022 * 创建人:lq */@RestControllerpublic class MyController &#123; private final Logger logger = Logger.getLogger(getClass()); @Autowired private DiscoveryClient client; @RequestMapping(value = \"/add\", method = RequestMethod.GET) public Integer add(@RequestParam Integer a, @RequestParam Integer b)&#123; ServiceInstance instance = client.getLocalServiceInstance(); Integer c = a + b; logger.info(\"/add, host:\" + instance.getHost() + \", service_id:\" + instance.getServiceId() + \", result:\" + c); return c; &#125;&#125; 在启动器上加入: @EnableDiscoveryClient注解,注册到服务中心 启动过后如图表明以及注册成功: 编写消费服务方 这里使用的 Feign 在最基本的springboot项目上添加依赖(注意添加依赖和上面的类型): 12345678910111213141516171819202122232425262728&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Brixton.SR5&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;/dependencyManagement&gt; 修改配置 12345678910111213server: port: 3333spring: application: # 显示在服务中心的名字,以及调用时的名字? name: compute-serviceeureka: client: serviceUrl: #指定服务中心 defaultZone: http://localhost:1111/eureka/ 编写调用接口 1234567891011@FeignClient(\"compute-service\") // 指定调用的服务名public interface ComputeClient &#123; //这里访问的路径,请求方式,参数都必须和服务提供端的一样 @RequestMapping(value = \"/add\", method = RequestMethod.GET) Integer add(@RequestParam(value = \"a\") Integer a, @RequestParam(value = \"b\") Integer b); //测试方法 @RequestMapping(value = \"/say\", method = RequestMethod.GET) String say();&#125; 编写Controller进行测试 123456789101112131415161718@RestControllerpublic class My &#123; //注入接口 @Autowired ComputeClient computeClient; @RequestMapping(value = \"/add\", method = RequestMethod.GET) public Integer add() &#123; return computeClient.add(10, 20); &#125; @RequestMapping(value = \"/say\", method = RequestMethod.GET) public String say()&#123; return computeClient.say(); &#125;&#125; 修改启动类 1234567891011@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class RibbonDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RibbonDemoApplication.class, args); &#125;&#125; 启动过后如图: 测试 这里我启动的两个服务提供方,端口指定不一样 访问服务消费者的add方法 第一次访问其中一个服务提供日志打印如下 再次访问add,另一个服务端打印结果 结论通过Feign以接口和注解配置的方式，轻松实现了对compute-service服务的绑定，这样我们就可以在本地应用中像本地服务一下的调用它，并且做到了客户端均衡负载。 但是如果访问3333的say方法,出现第一次访问如果是成功,第二次访问肯定404,这是因为启动了两个服务端,一个有say方法一个没有say方法,在Feign实现的客户端均衡负载的时候,是采用的遍历的方式应该,类似于上面的add方法,第一次访问第一个服务端,第二次访问第三个服务端.","categories":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://yoursite.com/categories/Spring-Cloud/"}],"tags":[{"name":"Spring,","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Cloud","slug":"Cloud","permalink":"http://yoursite.com/tags/Cloud/"}]},{"title":"integer和integer比较是否相同用==的问题","slug":"今天遇到integer和integer比较是否相同的问题","date":"2017-12-25T06:06:56.000Z","updated":"2018-07-20T07:11:44.684Z","comments":true,"path":"今天遇到integer和integer比较是否相同的问题.html","link":"","permalink":"http://yoursite.com/今天遇到integer和integer比较是否相同的问题.html","excerpt":"integer和integer比较是否相同的问题","text":"integer和integer比较是否相同的问题 今天在继续开发商城项目时,遇到一个问题,我根据地址取出用户ID(地址唯一),代码如下: 12345// 处理转账到自己的账户Integer userIdByAddress = getUserIdByAddress(address);if (userIdByAddress == Integer.valueOf(memberId)) &#123; return JsonResultUtil.getErrorJson(\"无法转账给自己\");&#125; 这里我测试的时候输入的自己的address也进入不了 在网上查了一下原因,大概是因为integer范围的问题 123456static final Integer cache[] = new Integer[-(-128) + 127 + 1]; static &#123; for(int i = 0; i &lt; cache.length; i++) cache[i] = new Integer(i - 128); &#125; 总结:这是源码中的，也就是说cache[]中已有-128到127，不在这范围的会新new ，这时可以理解比较是内存地址，也就是是不是同一对象.所以说当Integer的值不在-128到127的时候使用==方法判断是否相等就会出错，在这个范围之内的就会没有问题！以后最好用equals","categories":[{"name":"java开发遇到的问题","slug":"java开发遇到的问题","permalink":"http://yoursite.com/categories/java开发遇到的问题/"}],"tags":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"http://yoursite.com/tags/疑难杂症/"}]},{"title":"Spring Cloud自己学习的时候遇到的一些问题","slug":"Spring Cloud开发过程中遇到的一些问题","date":"2017-12-22T10:30:42.000Z","updated":"2018-07-20T07:13:25.948Z","comments":true,"path":"Spring Cloud开发过程中遇到的一些问题.html","link":"","permalink":"http://yoursite.com/Spring Cloud开发过程中遇到的一些问题.html","excerpt":"Spring Cloud自己学习的时候遇到的一些问题","text":"Spring Cloud自己学习的时候遇到的一些问题 Feign pom.xml引起问题的配置部分如下: 1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Brixton.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 报错内容 1Attribute 'value' in annotation [org.springframework.cloud.netflix.feign.FeignClient] must be declared as an @AliasFor [serviceId], not [name]. 解决方法 将Spring Cloud版本改为 Brixton.SR5 或 Camden.RELEASE ，即可解决此问题。","categories":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://yoursite.com/categories/Spring-Cloud/"}],"tags":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"http://yoursite.com/tags/疑难杂症/"}]},{"title":"IDEA新建项目时，没有Spring Initializr选项","slug":"IDEA新建项目时，没有Spring Initializr选项","date":"2017-12-22T08:17:16.000Z","updated":"2018-07-20T07:12:36.524Z","comments":true,"path":"IDEA新建项目时，没有Spring Initializr选项.html","link":"","permalink":"http://yoursite.com/IDEA新建项目时，没有Spring Initializr选项.html","excerpt":"IDEA新建项目时，没有Spring Initializr选项","text":"IDEA新建项目时，没有Spring Initializr选项 最近开始使用IDEA作为开发工具，然后也是打算开始学习使用spring cloud。看着博客来进行操作上手spring cloud，很多都是说创建一个新项目(Create New Project) 选择 Spring Initializr。然而我发现我的IDEA上面没有Spring Initializr这个选项。解决办法如下： 在settings -&gt; Plugins 里面搜索spring boot，勾选上，然后再重启下idea，就可以了。如果Plugins里面没有spring boot的话，先安装下，再勾选","categories":[{"name":"IDEA","slug":"IDEA","permalink":"http://yoursite.com/categories/IDEA/"}],"tags":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"http://yoursite.com/tags/疑难杂症/"}]},{"title":"Redis的更新策略(二)","slug":"Redis的更新策略(二)","date":"2017-12-22T06:02:06.000Z","updated":"2018-07-20T06:28:49.570Z","comments":true,"path":"Redis的更新策略(二).html","link":"","permalink":"http://yoursite.com/Redis的更新策略(二).html","excerpt":"Spring Boot中的缓存支持（二）使用Redis做集中式缓存","text":"Spring Boot中的缓存支持（二）使用Redis做集中式缓存 前言 阅读了一些资料,发现了一个更好更便捷的处理Redis缓存的方法,所以本菜鸡写下来记录一下 这里主要是使用Cache注解,所以下面会介绍一些Cache注解的资料 Cache注解详解 @CacheConfig 用例: 1234567@CacheConfig(cacheNames = \"users\")public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123; @Cacheable User findByName(String name);&#125; @CacheConfig：主要用于配置该类中会用到的一些共用的缓存配置。在这里@CacheConfig(cacheNames = &quot;users&quot;)：配置了该数据访问对象中返回的内容将存储于名为users的缓存对象中，我们也可以不使用该注解，直接通过@Cacheable自己配置缓存集的名字来定义。 @Cacheable：配置了findByName函数的返回值将被加入缓存。同时在查询时，会先从缓存中获取，若不存在才再发起对数据库的访问。该注解主要有下面几个参数： value、cacheNames：两个等同的参数（cacheNames为Spring 4新增，作为value的别名），用于指定缓存存储的集合名。由于Spring 4中新增了@CacheConfig，因此在Spring 3中原本必须有的value属性，也成为非必需项了 key：缓存对象存储在Map集合中的key值，非必需，缺省按照函数的所有参数组合作为key值，若自己配置需使用SpEL表达式，比如：@Cacheable(key = &quot;#p0&quot;)：使用函数第一个参数作为缓存的key值 condition：缓存对象的条件，非必需，也需使用SpEL表达式，只有满足表达式条件的内容才会被缓存，比如：@Cacheable(key = &quot;#p0&quot;, condition = &quot;#p0.length() &lt; 3&quot;)，表示只有当第一个参数的长度小于3的时候才会被缓存 unless：另外一个缓存条件参数，非必需，需使用SpEL表达式。它不同于condition参数的地方在于它的判断时机，该条件是在函数被调用之后才做判断的，所以它可以通过对result进行判断 keyGenerator：用于指定key生成器，非必需。若需要指定一个自定义的key生成器，我们需要去实现org.springframework.cache.interceptor.KeyGenerator接口，并使用该参数来指定。需要注意的是：该参数与key是互斥的 cacheManager：用于指定使用哪个缓存管理器，非必需。只有当有多个时才需要使用 cacheResolver：用于指定使用那个缓存解析器，非必需。需通过org.springframework.cache.interceptor.CacheResolver接口来实现自己的缓存解析器，并用该参数指定。 几个核心注解: @CachePut：配置于函数上，能够根据参数定义条件来进行缓存，它与@Cacheable不同的是，它每次都会真是调用函数，所以主要用于数据新增和修改操作上。它的参数与@Cacheable类似，具体功能可参考上面对@Cacheable参数的解析 @CacheEvict：配置于函数上，通常用在删除方法上，用来从缓存中移除相应数据。除了同@Cacheable一样的参数之外，它还有下面两个参数： allEntries：非必需，默认为false。当为true时，会移除所有数据 beforeInvocation：非必需，默认为false，会在调用方法之后移除数据。当为true时，会在调用方法之前移除数据 更多详细用例参照","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"SpringBoot,","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"SpringBoot整合mybatis","slug":"SpringBoot整合mybatis","date":"2017-12-22T03:42:54.000Z","updated":"2018-07-20T06:38:08.898Z","comments":true,"path":"SpringBoot整合mybatis.html","link":"","permalink":"http://yoursite.com/SpringBoot整合mybatis.html","excerpt":"SpringBoot整合mybatis,测试简单的CURD","text":"SpringBoot整合mybatis,测试简单的CURD 前言 整合springboot和mybatis仅仅为了学习和简单的使用 导入依赖 在pom.xml中引入依赖,如下:123456&lt;!--引入mybatis,因为带有JDBC所以不需要引入JDBC了--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt;&lt;/dependency&gt; 实体类 这里实体类,我是用的测试JPA时的实体类,也可以按照平常的写法,先private字段,在get,set也可以1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.example.demo.model;import javax.persistence.*;import java.io.Serializable;@Entity@Table(name=\"user\")public class SystemUser implements Serializable&#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) //id自增 @Column(name = \"id\") private Integer id; @Column(name=\"user_name\") private String name; @Column(name=\"user_password\") private String password; public SystemUser(String name, String password, Integer id) &#123; this.name = name; this.password = password; this.id = id; &#125; public SystemUser(String name, String password) &#123; this.name = name; this.password = password; &#125; @Override public String toString() &#123; return \"SystemUser&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", password='\" + password + '\\'' + '&#125;'; &#125; public SystemUser() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; 编写Dao层1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.example.mybatisDeno.mapper;import com.example.demo.model.SystemUser;import org.apache.ibatis.annotations.*;import java.util.List;/** * 创建时间:2017/12/22 0022 * 创建人:lq * 使用注解进行简单的增删改查 */@Mapper //@Mapper将UserDao声明为一个Mapper接口public interface UserDao &#123; @Results(&#123; @Result(property = \"id\", column = \"id\"), @Result(property = \"name\", column = \"user_name\"), @Result(property = \"password\", column = \"user_password\") &#125;) /** * 查询 */ @Select(\"SELECT * FROM user WHERE user_name = #&#123;name&#125;\") //3 List&lt;SystemUser&gt; get(String name); /** * 增加,返回增加元素的ID * @param user SystemUser实体 * @return 返回增加元素ID */ @Insert(\"INSERT INTO `user`(user_name,user_password) VALUES(#&#123;name&#125;,#&#123;password&#125;)\") @Options(useGeneratedKeys = true, keyColumn = \"id\", keyProperty = \"id\") Integer add(SystemUser user); /** * 删除 * @param id * @return 返回影响的行数 */ @Delete(\"Delete from user where id = #&#123;id&#125;\") Long delete(Integer id); /** * 修改 * @param user SystemUser实体 * @return 返回影响的行数 */ @Update(\"update user set user_name = #&#123;name&#125;, user_password = #&#123;password&#125; where id = #&#123;id&#125;\") Long update(SystemUser user);&#125; @Mapper 将UserDao声明为一个Mapper接口 @Results 字段与数据库的映射列表 @Result 进行详细的映射,其中property是User类的属性名，colomn是数据库表的字段名 @Select 写入查询 @Update 写入更新语句 @Delete 写入删除语句 @Insert 写入插入语句 @Options 设置主键,其中useGeneratedKeys是使用主键,keyProperty实体类中主键的名字,keyColumn数据库中主键的名字 编写service层 如下;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.example.mybatisDeno.service;import com.example.demo.model.SystemUser;import com.example.mybatisDeno.mapper.UserDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * 创建时间:2017/12/22 0022 * 创建人:lq */@Servicepublic class UserService &#123; @Autowired private UserDao userDao; /** * 根据name查询 * @param name * @return */ public List&lt;SystemUser&gt; get(String name)&#123; return userDao.get(name); &#125; /** * 增加 * @param name,password * @return */ public Integer add(String name, String password)&#123; SystemUser user = new SystemUser(name,password); return userDao.add(user); &#125; /** * 删除 * @param id * @return */ public Long delete(Integer id)&#123; return userDao.delete(id); &#125; /** * 修改 * @param name,password * @return */ public Long update(String name, String password, Integer id)&#123; SystemUser user = new SystemUser(name, password, id); return userDao.update(user); &#125;&#125; 编写controller层12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.example.mybatisDeno.controller;import com.example.demo.model.SystemUser;import com.example.mybatisDeno.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import java.util.List;/** * 创建时间:2017/12/22 0022 * 创建人:lq */@RestController@RequestMapping(value = \"/mb\")public class UserController &#123; @Autowired private UserService userService; @RequestMapping(value = \"/\") public String hello()&#123; return \"mybatis\"; &#125; @RequestMapping(value = \"/get\") public List&lt;SystemUser&gt; get(@RequestParam String name)&#123; return userService.get(name); &#125; @RequestMapping(value = \"/add\") public Integer add(@RequestParam String name, @RequestParam String password)&#123; return userService.add(name, password); &#125; @RequestMapping(value = \"/delete\") public Long delete(@RequestParam Integer id)&#123; return userService.delete(id); &#125; @RequestMapping(value = \"/update\") public Long update(@RequestParam String name, @RequestParam String password, @RequestParam Integer id)&#123; return userService.update(name, password ,id); &#125;&#125; 总结 这里详细说明一下MyBatis注解 使用@Param如下代码: 12@Insert(\"INSERT INTO USER(NAME, AGE) VALUES(#&#123;name&#125;, #&#123;age&#125;)\")int insert(@Param(\"name\") String name, @Param(\"age\") Integer age); 这种方式很好理解，@Param中定义的name对应了SQL中的#{name}，age对应了SQL中的#{age} 使用Map如下代码: 12@Insert(\"INSERT INTO USER(NAME, AGE) VALUES(#&#123;name,jdbcType=VARCHAR&#125;, #&#123;age,jdbcType=INTEGER&#125;)\")int insertByMap(Map&lt;String, Object&gt; map); 对于Insert语句中需要的参数，我们只需要在map中填入同名的内容即可，具体如下面代码所示： 1234Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.put(\"name\", \"CCC\");map.put(\"age\", 40);userMapper.insertByMap(map); 使用对象 可直接使用普通的Java对象来作为查询条件的传参，比如我们可以直接使用User对象: 12@Insert(\"INSERT INTO USER(NAME, AGE) VALUES(#&#123;name&#125;, #&#123;age&#125;)\")int insertByUser(User user);","categories":[{"name":"SoringBoot","slug":"SoringBoot","permalink":"http://yoursite.com/categories/SoringBoot/"}],"tags":[{"name":"SpringBoot,","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"SoringBoot正常启动,但是页面Whitelabel Error Page","slug":"SpringBoot正常启动,但是页面Whitelabel Error Page","date":"2017-12-22T03:13:12.000Z","updated":"2018-07-20T06:36:47.467Z","comments":true,"path":"SpringBoot正常启动,但是页面Whitelabel Error Page.html","link":"","permalink":"http://yoursite.com/SpringBoot正常启动,但是页面Whitelabel Error Page.html","excerpt":"SoringBoot正常启动,但是页面Whitelabel Error Page","text":"SoringBoot正常启动,但是页面Whitelabel Error Page 环境: idea + springboot 项目结构如下: 情况描述:启动DemoApplication正常启动没报任何错误,访问mybatisDemo下的controller无法访问,但是访问demo下的controller可以访问. 问题原因:我觉得spring boot只会扫描启动类当前包和以下的包,如果将启动类放到demo下,就只会扫描demo下的 解决方法:将启动类放到mybatisDemo下","categories":[{"name":"SoringBoot","slug":"SoringBoot","permalink":"http://yoursite.com/categories/SoringBoot/"}],"tags":[{"name":"SpringBoot,","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"启动报错","slug":"启动报错","permalink":"http://yoursite.com/tags/启动报错/"}]},{"title":"Redis的更新策略","slug":"Redis的更新策略","date":"2017-12-20T02:23:12.000Z","updated":"2018-07-20T06:32:34.641Z","comments":true,"path":"Redis的更新策略.html","link":"","permalink":"http://yoursite.com/Redis的更新策略.html","excerpt":"SpringBoot + Redis的缓存更新策略","text":"SpringBoot + Redis的缓存更新策略 前言 这里才用的模式为Cache Aside,这是标准的design pattern.它的具体逻辑如下: 失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。 命中：应用程序从cache中取数据，取到后返回。 更新：先把数据存到数据库中，成功后，再让缓存失效。 详细资料:缓存更新的套路 项目具体配置 pom.xml依赖配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 核心模块，包括自动配置支持、日志和YAML --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 测试模块，包括JUnit、Hamcrest、Mockito --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 引入web依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 引入JDBC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 引入MYSQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- JPA --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--redis配置依赖关系--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置数据源1234567#mysqlspring: datasource: url: jdbc:mysql://localhost:3306/test driver-class-name: com.mysql.jdbc.Driver username: root password: root 配置JPA1234567891011121314151617181920212223#jpa jpa: #指定JPA数据库 database: mysql #showSql show-sql: true #hibernate.hbm2ddl.auto节点的值有几个create、create-drop、update、validate、none #create：每次加载hibernate会自动创建表，以后启动会覆盖之前的表，所以这个值基本不用，严重会导致的数据的丢失。 #create-drop ： 每次加载hibernate时根据model类生成表，但是sessionFactory一关闭，表就自动删除，下一次启动会重新创建。 #update：加载hibernate时根据实体类model创建数据库表，这是表名的依据是@Entity注解的值或者@Table注解的值，sessionFactory关闭表不会删除，且下一次启动会根据实体model更新结构或者有新的实体类会创建新的表。 #validate：启动时验证表的结构，不会创建表 #none：启动时不做任何操作 hibernate: ddl-auto: none #命名策略 naming: strategy: org.hibernate.cfg.ImprovedNamingStrategy 配置Redis123456789101112131415161718192021#redis redis: #Redis数据库索引（默认为0） database: 0 # Redis服务器地址 host: 192.168.3.58 # Redis服务器连接端口 port: 6379 # Redis服务器连接密码(默认为空) password: pool: # 连接池最大连接数（使用负值表示没有限制） maxActice: 8 # 连接池最大阻塞等待时间（使用负值表示没有限制） maxWait: -1 # 连接池中的最大空闲连接 maxIdle: 8 # 连接池中的最小空闲连接 minIdle: 0 # 连接超时时间（毫秒） timeout: 0 建立实体类 下面的开发全部基于SpringBoot + JPA + Redis 实体类如下(必须实现序列化):1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.example.demo.model;import javax.persistence.*;import java.io.Serializable;@Entity@Table(name=\"user\")public class SystemUser implements Serializable&#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) //id自增 @Column(name = \"id\") private Integer id; @Column(name=\"user_name\") private String name; @Column(name=\"user_password\") private String password; public SystemUser(String name, String password) &#123; this.name = name; this.password = password; &#125; @Override public String toString() &#123; return \"SystemUser&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", password='\" + password + '\\'' + '&#125;'; &#125; public SystemUser() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; 缓存更新策略的具体实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.example.demo.controller;import com.example.demo.model.SystemUser;import com.example.demo.service.IUserService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.concurrent.TimeUnit;/** * 创建时间:2017/12/20 0020 * 创建人:lq */@RestController@RequestMapping(value = \"redis\")public class RedisController &#123; private Logger log = LoggerFactory.getLogger(\"RedisDemo\"); @Autowired private IUserService userService; @Autowired private RedisTemplate redisTemplate; /** * 获取User逻辑 * 如果缓存中存在就从缓存区取出 * 不存在就从DB中取出,然后插入缓存 * @param id * @return */ @RequestMapping(value = \"find\") public SystemUser findOne(Integer id)&#123; String key = \"User_id\" + id; //如果缓存中存在就取出 if (redisTemplate.hasKey(key))&#123; SystemUser user = (SystemUser) redisTemplate.opsForValue().get(key); log.info(\"RedisController.findOne():从缓存中取出SystemUser &gt;&gt;&gt;\" + user.toString()); return user; &#125; //不存在就在DB中取出 SystemUser user = userService.findOne(id); //插入缓存 redisTemplate.opsForValue().set(key, user, 60, TimeUnit.SECONDS); log.info(\"RedisController.findOne():插入User缓存 &gt;&gt;&gt;\" + user.toString()); return user; &#125; /** * 更新User逻辑 * 先更新 * 如果缓存存在删除,不存在不操作 */ @RequestMapping(value = \"up\") public SystemUser update()&#123; SystemUser user = new SystemUser(); user.setId(2); user.setPassword(\"123\"); user.setName(\"p\"); userService.save(user); String key = \"User_id\" + user.getId(); if (redisTemplate.hasKey(key))&#123; log.info(\"RedisController.update():从缓存中移除SystemUser &gt;&gt;&gt;\" + user.toString()); redisTemplate.delete(key); &#125; return user; &#125;&#125; 第一次访问findOne(): 访问修改方法update(): 再次访问查找findOne(): 总结 采用Cache Aside的话,并发操作的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"SpringBoot,","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"SpringBoot整合Redis","slug":"SpringBoot 整合Redis","date":"2017-12-19T09:48:12.000Z","updated":"2018-07-20T06:34:00.915Z","comments":true,"path":"SpringBoot 整合Redis.html","link":"","permalink":"http://yoursite.com/SpringBoot 整合Redis.html","excerpt":"记录下第一整合过程","text":"记录下第一整合过程 [TOC] 1前言 Redis服务器在虚拟机中搭建,系统为Ubuntu,Redis版本为4.0.6;文件配置均在application.yml中完成 2.springBoot添加Redis依赖 在pom.xml添加依赖:12345&lt;!--redis配置依赖关系--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 3.Redis单机配置123456789101112131415161718192021#redis redis: #Redis数据库索引（默认为0） database: 0 # Redis服务器地址 host: 192.168.3.58 # Redis服务器连接端口 port: 6379 # Redis服务器连接密码(默认为空) password: pool: # 连接池最大连接数（使用负值表示没有限制） maxActice: 8 # 连接池最大阻塞等待时间（使用负值表示没有限制） maxWait: -1 # 连接池中的最大空闲连接 maxIdle: 8 # 连接池中的最小空闲连接 minIdle: 0 # 连接超时时间（毫秒） timeout: 0 4.编写Redis测试用例这个用例中完成了Redis对字符的存储,和对对象的存储注意: SystemUser这个对象必须实现Serializable接口,否则会报错 RedisDemo.java 12345678910111213141516171819202122232425262728293031/** * 创建时间:2017/12/19 0019 * 创建人:lq * Redis简单存取操作 */@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = DemoApplication.class)public class RedisDemo &#123; @Autowired private RedisTemplate redisTemplate; @Autowired private StringRedisTemplate stringRedisTemplate; private Logger log = LoggerFactory.getLogger(\"RedisDemo\"); @Test public void test()&#123; stringRedisTemplate.opsForValue().set(\"name\",\"pock\"); SystemUser user = new SystemUser(\"admin\",\"123\"); redisTemplate.opsForValue().set(\"user\",user); log.info(\"success\"); &#125; @After public void testGet()&#123; SystemUser user = (SystemUser) redisTemplate.opsForValue().get(\"user\"); log.info(user.getName()); &#125;&#125; RedisTemplate:会使用JdkSerializationRedisSerializer，这意味着key和value都会通过Java进行序列化。 StringRedisTemplate默认会使用StringRedisSerializer 结束到这里就实现了一个最简单的springboot整合Redis的demo","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot,","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"SpringBoot依赖整理","slug":"SpringBoot依赖整理","date":"2017-12-19T06:09:00.000Z","updated":"2018-07-20T06:38:21.369Z","comments":true,"path":"SpringBoot依赖整理.html","link":"","permalink":"http://yoursite.com/SpringBoot依赖整理.html","excerpt":"整理下吧","text":"整理下吧 前言 以下的配置全部在application.yml文件中配置 均为在学习过程中的总结1.核心模块 核心模块，包括自动配置支持、日志和YAML12345&lt;!-- 核心模块，包括自动配置支持、日志和YAML --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 2.测试模块 测试模块，包括JUnit、Hamcrest、Mockito123456&lt;!-- 测试模块，包括JUnit、Hamcrest、Mockito --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 3.web依赖 web依赖12345&lt;!-- 引入web依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 4.JDBC依赖 JDBC依赖 12345&lt;!-- 引入JDBC --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 参数配置 1234567#mysqlspring: datasource: url: jdbc:mysql://localhost:3306/test driver-class-name: com.mysql.jdbc.Driver username: root password: root 5.MYSQL驱动 MYSQL驱动12345&lt;!-- 引入MYSQL驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 6.引入JPA 引入JPA 12345&lt;!-- JPA --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 参数配置 1234567891011121314151617181920212223#jpa jpa: #指定JPA数据库 database: mysql #showSql show-sql: true #hibernate.hbm2ddl.auto节点的值有几个create、create-drop、update、validate、none #create：每次加载hibernate会自动创建表，以后启动会覆盖之前的表，所以这个值基本不用，严重会导致的数据的丢失。 #create-drop ： 每次加载hibernate时根据model类生成表，但是sessionFactory一关闭，表就自动删除，下一次启动会重新创建。 #update：加载hibernate时根据实体类model创建数据库表，这是表名的依据是@Entity注解的值或者@Table注解的值，sessionFactory关闭表不会删除，且下一次启动会根据实体model更新结构或者有新的实体类会创建新的表。 #validate：启动时验证表的结构，不会创建表 #none：启动时不做任何操作 hibernate: ddl-auto: none #命名策略 naming: strategy: org.hibernate.cfg.ImprovedNamingStrategy 7.引入Redis12345&lt;!--redis配置依赖关系--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; Redis单机参数配置123456789101112131415161718192021#redis redis: #Redis数据库索引（默认为0） database: 0 # Redis服务器地址 host: 192.168.3.58 # Redis服务器连接端口 port: 6379 # Redis服务器连接密码(默认为空) password: pool: # 连接池最大连接数（使用负值表示没有限制） maxActice: 8 # 连接池最大阻塞等待时间（使用负值表示没有限制） maxWait: -1 # 连接池中的最大空闲连接 maxIdle: 8 # 连接池中的最小空闲连接 minIdle: 0 # 连接超时时间（毫秒） timeout: 0 引入mybatis12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt;&lt;/dependency&gt; 引入cassandra数据库?12345&lt;!--引入cassandra数据库?--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-cassandra&lt;/artifactId&gt;&lt;/dependency&gt; springboot热部署1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot,","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"依赖","slug":"依赖","permalink":"http://yoursite.com/tags/依赖/"}]},{"title":"SpringBoot启动报错The import org.springframework.data.repository.query.Param cannot be resolved","slug":"SpringBoot启动报错 The import org.springframework.data.repository.query.Param cannot be resolved","date":"2017-12-19T02:31:31.000Z","updated":"2018-07-20T07:15:34.122Z","comments":true,"path":"SpringBoot启动报错 The import org.springframework.data.repository.query.Param cannot be resolved.html","link":"","permalink":"http://yoursite.com/SpringBoot启动报错 The import org.springframework.data.repository.query.Param cannot be resolved.html","excerpt":"SpringBoot启动报错The import org.springframework.data.repository.query.Param cannot be resolved","text":"SpringBoot启动报错The import org.springframework.data.repository.query.Param cannot be resolved 描述:在sprigBoot启动时遇到:The import org.springframework.data.repository.query.Param cannot be resolved 解决方式mvn clean dependency:tree 命令看看依赖是否有问题在运行mvn clean compile看是否失败,成功就没啥问题了 到这里重新启动就解决了问题","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot,","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"报错","slug":"报错","permalink":"http://yoursite.com/tags/报错/"}]},{"title":"SpringBoot异常统一处理","slug":"SpringBoot异常统一处理","date":"2017-12-18T03:40:00.000Z","updated":"2018-07-20T06:41:03.251Z","comments":true,"path":"SpringBoot异常统一处理.html","link":"","permalink":"http://yoursite.com/SpringBoot异常统一处理.html","excerpt":"SpringBoot异常统一处理(初学记录下)","text":"SpringBoot异常统一处理(初学记录下) 1.建立测试异常123456789@RestController@RequestMapping(value = \"/ecpc\")public class ExceptionController &#123; @RequestMapping(value = \"/ecpc1\") public String ecpcTest() throws Exception &#123; throw new Exception(\"发生错误\"); &#125;&#125; 不进行处理的话访问 http://localhost:8080/ecpc/ecpc1,会出下面的界面 2.统一异常处理类123456789101112@RestControllerAdvice //定义统一的异常处理类public class GlobalExceptionHandler &#123; private Logger log = LoggerFactory.getLogger(\"GlobalExceptionHandler\"); @ResponseBody @ExceptionHandler(value = Exception.class ) //定义针对的异常类型,这里捕获Exception类型和其所用子异常 public Object errorHandler(HttpServletRequest req, Exception e) throws Exception &#123; log.error(\"---DefaultException Handler---Host &#123;&#125; invokes url &#123;&#125; ERROR: &#123;&#125;\",req.getRemoteHost(),req.getRequestURL(),e.getMessage()); return e.getMessage(); &#125;&#125; @RestControllerAdvice 表明GlobalExceptionHandler 是一个全局的异常处理器,也是是一个 RESTful Controller, 即它会以 RESTful 的形式返回回复.(类注解, 作用于 整个 Spring 工程. ControllerAdvice 注解定义了一个全局的异常处理器,如果你们的异常需要返回页面啊之类的，你可以使用@ControllerAdvice分别定制。) ExceptionHandler(value = Exception.class ) 表示 defaultErrorHandler 会处理 Exception 异常和其所用子异常(作用于 Controller 级别. ExceptionHandler 注解为一个 Controler 定义一个异常处理器) 捕获效果如图: 控制台打印效果如图:","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot,","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"异常处理","slug":"异常处理","permalink":"http://yoursite.com/tags/异常处理/"}]},{"title":"SpringBoot注解随记","slug":"SpringBoot注解随记","date":"2017-12-15T12:14:52.000Z","updated":"2018-07-20T07:23:08.974Z","comments":true,"path":"SpringBoot注解随记.html","link":"","permalink":"http://yoursite.com/SpringBoot注解随记.html","excerpt":"记录一些工作中遇到的注解方便以后查找,2017年12月19日","text":"记录一些工作中遇到的注解方便以后查找,2017年12月19日 前言记录一些工作中遇到的注解方便以后查找,2017年12月19日 @RestController @RestController4.0之前的版本，SpringMVC的组件都使用@Controller来标识当前类是一个控制器servlet,现在@RestController 就相当于标识当前类为Controller,支持返回xml和json @RequestMapping @RequestMapping(value=&quot;/users&quot;)在Controller层上配置 1234@RestController@RequestMapping(value = \"/user\") // 通过这里配置使下面的映射都在/user下public class UserController &#123;&#125; @RequestMapping(value=”/“, method=RequestMethod.GET)这里指定了访问的类型GET,相似的还有 Method 请求类型 method=RequestMethod.GET GET请求 method=RequestMethod.POST POST请求 method=RequestMethod.PUT PUT请求 method=RequestMethod.DELETE DELETE请求 可以用这个方式实现RESTful API RESTful API设计思想大概: 请求类型 URL 功能说明 GET /users 查询用户列表 POST /users 创建一个用户 GET /users?id= 根据ID查询一个用户 PUT /users?id= 根据ID更新一个用户 DELETE /users?id= 根据ID删除一个用户 示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 @RestController @RequestMapping(value=\"/users\") // 通过这里配置使下面的映射都在/users下 public class UserController &#123; @RequestMapping(value=\"/\", method=RequestMethod.GET) public List&lt;User&gt; getUserList() &#123; // 处理\"/users/\"的GET请求，用来获取用户列表 // 还可以通过@RequestParam从页面中传递参数来进行查询条件或者翻页信息的传递 List&lt;User&gt; r = new ArrayList&lt;User&gt;(users.values()); return r; &#125; @RequestMapping(value=\"/\", method=RequestMethod.POST) public String postUser(@ModelAttribute User user) &#123; // 处理\"/users/\"的POST请求，用来创建User // 除了@ModelAttribute绑定参数之外，还可以通过@RequestParam从页面中传递参数 users.put(user.getId(), user); return \"success\"; &#125; @RequestMapping(value=\"/&#123;id&#125;\", method=RequestMethod.GET) public User getUser(@PathVariable Long id) &#123; // 处理\"/users/&#123;id&#125;\"的GET请求，用来获取url中id值的User信息 // url中的id可通过@PathVariable绑定到函数的参数中 return users.get(id); &#125; @RequestMapping(value=\"/&#123;id&#125;\", method=RequestMethod.PUT) public String putUser(@PathVariable Long id, @ModelAttribute User user) &#123; // 处理\"/users/&#123;id&#125;\"的PUT请求，用来更新User信息 User u = users.get(id); u.setName(user.getName()); u.setAge(user.getAge()); users.put(id, u); return \"success\"; &#125; @RequestMapping(value=\"/&#123;id&#125;\", method=RequestMethod.DELETE) public String deleteUser(@PathVariable Long id) &#123; // 处理\"/users/&#123;id&#125;\"的DELETE请求，用来删除User users.remove(id); return \"success\"; &#125; &#125; @PathVariable @PathVariable作用:映射 URL 绑定的占位符示例:1234567//@PathVariable可以用来映射URL中的占位符到目标方法的参数中@RequestMapping(\"/testPathVariable/&#123;id&#125;\") public String testPathVariable(@PathVariable(\"id\") Integer id) &#123; System.out.println(\"testPathVariable:\"+id); return SUCCESS; &#125; @ModelAttribute @ModelAttribute1234@RequestMapping(value=\"/\", method=RequestMethod.POST) public String postUser(@ModelAttribute User user) &#123; // 处理POST请求，用来创建User &#125; @RequestParam @RequestParam一种是request.getParameter(&quot;name&quot;)，另外一种是用注解@RequestParam直接获取示例12345678910@RequestMapping(\"testRequestParam\") public String filesUpload(@RequestParam String inputStr, HttpServletRequest request) &#123; System.out.println(inputStr); int inputInt = Integer.valueOf(request.getParameter(\"inputInt\")); System.out.println(inputInt); // ......省略 return \"index\"; &#125; @ControllerAdvice @ControllerAdvice作用于 整个 Spring 工程. ControllerAdvice 注解定义了一个全局的异常处理器,详情在异常处理的那一篇博客里面@ControllerAdvice呢也有个相似的@RestControllerAdvice @ExceptionHandler捕获异常,以及异常的子类,详细用法在在异常处理的那一篇博客里面 @RunWith @RunWith使用RunWith注解改变JUnit的默认执行类，并实现自已的Listener在平时的单元测试，如果不使用RunWith注解，那么JUnit将会采用默认的执行类Suite执行，如下类： 12345678public class SimpleJunitTest &#123; @Test public void testSayHi() &#123; System.out.println(\"Hi Junit.\"); &#125; &#125; @RunWith(SpringJUnit4ClassRunner.class)，这里就指定的是SpringJUnit4ClassRunner.class,如下类: 1234567891011121314151617181920@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = MockServletContext.class)public class HttpTest &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; //绑定需要测试的Controller到MockMvc上 mvc = MockMvcBuilders.standaloneSetup(new HelloWordTest()).build(); &#125; @Test public void getHello() throws Exception &#123; //发出请求，在请求中可以设置一个http request可设置的所有参数 mvc.perform(MockMvcRequestBuilders.get(\"/basic/hello\").accept(MediaType.APPLICATION_JSON)) .andExpect(status().isOk()) .andExpect(content().string(equalTo(\"hello\"))); &#125;&#125; @SpringApplicationConfiguration @SpringApplicationConfiguration废弃 @SpringBootTest @SpringBootTest@SpringBootTest替代了@SpringApplicationConfiguration具体用法规定启动容器?如下类:1234567891011121314@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = DemoApplication.class)public class RedisDemo &#123; @Test public void test()&#123; //测试方法 &#125; @After public void testGet()&#123; //测试方法 &#125;&#125; @DataJpaTest @DataJpaTest目前我已知的可用在测试JPA中(毕竟我还是个菜鸟)@DataJpaTest注解它只扫描@Entity 和装配 Spring Data JPA 存储库，其他常规的@Component（包括@Service、@Repository等）Bean 则不会被加载到 Spring 测试环境上下文。如下类:123456789101112131415161718@RunWith(SpringRunner.class)@DataJpaTestpublic class UserRepositoryInMemoryTest &#123; @Autowired private UserRepository userRepository; @Test public void testSave() &#123; User user = new User(); user.setName(\"fanlychie\"); userRepository.save(user); System.out.println(\"====================================\"); System.out.println(userRepository.findAll()); System.out.println(\"====================================\"); &#125; &#125; @Entity,@Table,@Id,@GeneratedValue,@Column @Entity,@Entity,@Table,@Id,@GeneratedValue,@Column 这里把这几个注解一起记录,因为一般都是在一起用的具体使用的方法如下类(结合JPA使用):12345678910111213141516@Entity //表明为实体类@Table(name=\"user\") //指定对应的表public class SystemUser implements Serializable&#123; @Id //表明主键 @GeneratedValue(strategy = GenerationType.IDENTITY) //表明id为自增 @Column(name = \"id\") //在表中对应的字段 private Integer id; @Column(name=\"user_name\") private String name; @Column(name=\"user_password\") private String password; //....省略Geter,Seter&#125; @Mapper,@Results,@Result,@Select,@Update,@Delete,@Insert,@Options @Mapper将UserDao声明为一个Mapper接口 @Results 字段与数据库的映射列表 @Result 进行详细的映射,其中property是User类的属性名，colomn是数据库表的字段名 @Select 写入查询 @Update 写入更新语句 @Delete 写入删除语句 @Insert 写入插入语句 @Options 设置主键,其中useGeneratedKeys是使用主键,keyProperty实体类中主键的名字,keyColumn数据 详细的用法可以参照…. @GetMapping,@PostMapping,@PutMapping,@DeleteMapping,@PatchMapping 这些注解是spring4.3引进的,自己感觉更便于开发RESTful风格的接口 拿 以@GetMapping为例，Spring官方文档说：@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。该注解将HTTP Get 映射到 特定的处理方法上。 其它的同理 @SpringBootApplication @SpringBootApplication 在springboot的启动类上,具体如下: 12345678import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication //开启组件扫描和自动配置public class ReadingListApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ReadingListApplication.class, args); //负责启动引导应用程序 &#125;&#125; @SpringBootApplication 开启了Spring的组件扫描和Spring Boot的自动配置功能。实际上， @SpringBootApplication 将三个有用的注解组合在了一起 Spring的 @Configuration ：标明该类使用Spring基于Java的配置。 Spring的 @ComponentScan ：启用组件扫描，这样你写的Web控制器类和其他组件才能被自动发现并注册为Spring应用程序上下文里的Bean Spring Boot 的 @EnableAutoConfiguration ： 这 个 不 起 眼 的 小 注 解 也 可 以 称 为@Abracadabra @SpringApplicationConfiguration @SpringApplicationConfiguration 1@SpringApplicationConfiguration(classes = ReadingListApplication.class) 通过 Spring Boot加载上下文","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot,","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"注解","slug":"注解","permalink":"http://yoursite.com/tags/注解/"}]}]}